/**
 * ðŸ”¬ EXPERIMENTAL: Comprehensive Permissions Policy Implementation
 * Fine-Grained Feature Control (2024-2025)
 *
 * Implements cutting-edge Permissions Policy for granular control over browser features,
 * including experimental APIs and privacy-sensitive capabilities.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Permissions-Policy
 * @see https://github.com/w3c/webappsec-permissions-policy
 * @see https://www.w3.org/TR/permissions-policy-1/
 */

import { logger } from "@/lib/utils/logger";

// ============================================================================\n// PERMISSIONS POLICY CONFIGURATION\n// ============================================================================\n\n/**\n * Comprehensive permissions policy directives\n * Based on latest specifications and experimental features\n */\nconst PERMISSIONS_DIRECTIVES = {\n  // ===== CORE WEB PLATFORM =====\n  \n  // Media capture\n  camera: {\n    description: 'Access to camera devices',\n    experimental: false,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  microphone: {\n    description: 'Access to microphone devices',\n    experimental: false,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  'display-capture': {\n    description: 'Screen sharing and display capture',\n    experimental: false,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  'captured-surface-control': {\n    description: 'Control over captured surfaces',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  \n  // Geolocation and sensors\n  geolocation: {\n    description: 'Geographic location data',\n    experimental: false,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  accelerometer: {\n    description: 'Device acceleration data',\n    experimental: false,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  gyroscope: {\n    description: 'Device orientation data',\n    experimental: false,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  magnetometer: {\n    description: 'Device magnetic field data',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'ambient-light-sensor': {\n    description: 'Ambient light sensing',\n    experimental: true,\n    riskLevel: 'low',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== EXPERIMENTAL PRIVACY FEATURES =====\n  \n  // Attribution and tracking\n  'attribution-reporting': {\n    description: 'Attribution Reporting API for ads',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  'browsing-topics': {\n    description: 'Topics API for interest-based ads',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  'private-aggregation': {\n    description: 'Private Aggregation API',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'shared-storage': {\n    description: 'Shared Storage API',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'shared-storage-select-url': {\n    description: 'Shared Storage URL selection',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== DEVICE INTEGRATION =====\n  \n  // Hardware access\n  usb: {\n    description: 'USB device access',\n    experimental: false,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  serial: {\n    description: 'Serial port access',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  bluetooth: {\n    description: 'Bluetooth device access',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  hid: {\n    description: 'Human Interface Device access',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== AI AND MACHINE LEARNING =====\n  \n  'compute-pressure': {\n    description: 'System pressure monitoring',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'language-detector': {\n    description: 'Language detection API',\n    experimental: true,\n    riskLevel: 'low',\n    defaultPolicy: 'none'\n  },\n  'translator': {\n    description: 'Translation API',\n    experimental: true,\n    riskLevel: 'low',\n    defaultPolicy: 'none'\n  },\n  'summarizer': {\n    description: 'Content summarization API',\n    experimental: true,\n    riskLevel: 'low',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== AUTHENTICATION & SECURITY =====\n  \n  'identity-credentials-get': {\n    description: 'Federated identity credentials',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  'publickey-credentials-create': {\n    description: 'WebAuthn credential creation',\n    experimental: false,\n    riskLevel: 'medium',\n    defaultPolicy: 'self'\n  },\n  'publickey-credentials-get': {\n    description: 'WebAuthn credential retrieval',\n    experimental: false,\n    riskLevel: 'medium',\n    defaultPolicy: 'self'\n  },\n  'otp-credentials': {\n    description: 'OTP credential access',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== USER EXPERIENCE =====\n  \n  fullscreen: {\n    description: 'Fullscreen display mode',\n    experimental: false,\n    riskLevel: 'low',\n    defaultPolicy: 'self'\n  },\n  'picture-in-picture': {\n    description: 'Picture-in-picture video',\n    experimental: false,\n    riskLevel: 'low',\n    defaultPolicy: 'self'\n  },\n  'window-management': {\n    description: 'Multi-window management',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'screen-wake-lock': {\n    description: 'Prevent screen from sleeping',\n    experimental: false,\n    riskLevel: 'low',\n    defaultPolicy: 'self'\n  },\n  \n  // ===== CROSS-ORIGIN ISOLATION =====\n  \n  'cross-origin-isolated': {\n    description: 'Cross-origin isolation status',\n    experimental: true,\n    riskLevel: 'low',\n    defaultPolicy: 'self'\n  },\n  \n  // ===== FONTS AND STORAGE =====\n  \n  'local-fonts': {\n    description: 'Access to locally installed fonts',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'none'\n  },\n  'storage-access': {\n    description: 'Third-party storage access',\n    experimental: true,\n    riskLevel: 'high',\n    defaultPolicy: 'none'\n  },\n  \n  // ===== PERFORMANCE MONITORING =====\n  \n  'execution-while-not-rendered': {\n    description: 'Background execution control',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'self'\n  },\n  'execution-while-out-of-viewport': {\n    description: 'Out-of-viewport execution control',\n    experimental: true,\n    riskLevel: 'medium',\n    defaultPolicy: 'self'\n  }\n};\n\n/**\n * Route-based permission policies\n */\nconst ROUTE_POLICIES = {\n  // Public marketing pages - very restrictive\n  '/': {\n    camera: 'none',\n    microphone: 'none',\n    geolocation: 'none',\n    'attribution-reporting': 'none',\n    'browsing-topics': 'none',\n    'local-fonts': 'none'\n  },\n  \n  // Authentication pages\n  '/auth': {\n    camera: 'self', // For profile photos\n    'publickey-credentials-create': 'self',\n    'publickey-credentials-get': 'self',\n    'otp-credentials': 'self'\n  },\n  \n  // Business dashboard - moderate permissions\n  '/dashboard': {\n    camera: 'self',\n    microphone: 'self',\n    geolocation: 'self',\n    fullscreen: 'self',\n    'picture-in-picture': 'self',\n    'screen-wake-lock': 'self',\n    'local-fonts': 'self'\n  },\n  \n  // Admin interface - high security\n  '/admin': {\n    camera: 'none',\n    microphone: 'none',\n    'attribution-reporting': 'none',\n    'browsing-topics': 'none',\n    'storage-access': 'none',\n    'cross-origin-isolated': 'self'\n  },\n  \n  // API routes\n  '/api': {\n    camera: 'none',\n    microphone: 'none',\n    geolocation: 'none',\n    'cross-origin-isolated': 'self'\n  },\n  \n  // High-performance analytics\n  '/analytics': {\n    'compute-pressure': 'self',\n    'cross-origin-isolated': 'self',\n    'private-aggregation': 'self'\n  }\n};\n\n// ============================================================================\n// PERMISSIONS POLICY MANAGER\n// ============================================================================\n\nclass PermissionsPolicyManager {\n  constructor() {\n    this.isSupported = this.checkSupport();\n    this.appliedPolicies = new Map();\n    this.violationReports = [];\n    this.initialized = false;\n  }\n\n  /**\n   * Check if Permissions Policy is supported\n   */\n  checkSupport() {\n    if (typeof window === 'undefined') return true; // Assume supported on server\n    \n    // Check for basic Permissions Policy support\n    return 'permissions' in navigator || 'permissionsPolicy' in document;\n  }\n\n  /**\n   * Initialize permissions policy monitoring\n   */\n  initialize() {\n    if (this.initialized) return;\n    \n    this.setupViolationReporting();\n    this.detectCurrentPolicies();\n    this.monitorFeatureUsage();\n    \n    this.initialized = true;\n    \n    logger.security({\n      type: 'permissions_policy_initialized',\n      supported: this.isSupported,\n      appliedPolicies: Array.from(this.appliedPolicies.keys()),\n      timestamp: Date.now()\n    });\n  }\n\n  /**\n   * Setup violation reporting\n   */\n  setupViolationReporting() {\n    if (typeof window === 'undefined') return;\n    \n    // Listen for permissions policy violations\n    document.addEventListener('securitypolicyviolation', (event) => {\n      if (event.violatedDirective.includes('permissions-policy')) {\n        this.handleViolation(event);\n      }\n    });\n  }\n\n  /**\n   * Handle permissions policy violations\n   */\n  handleViolation(event) {\n    const violation = {\n      directive: event.violatedDirective,\n      blockedURI: event.blockedURI,\n      sourceFile: event.sourceFile,\n      lineNumber: event.lineNumber,\n      columnNumber: event.columnNumber,\n      sample: event.sample,\n      timestamp: Date.now()\n    };\n    \n    this.violationReports.push(violation);\n    \n    logger.security({\n      type: 'permissions_policy_violation',\n      violation,\n      timestamp: Date.now()\n    });\n    \n    // Send to monitoring service\n    this.reportViolation(violation);\n  }\n\n  /**\n   * Report violation to external service\n   */\n  async reportViolation(violation) {\n    if (typeof fetch === 'undefined') return;\n    \n    try {\n      await fetch('/api/security/permissions-violations', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          type: 'permissions_policy_violation',\n          violation,\n          userAgent: navigator.userAgent,\n          url: window.location.href,\n          timestamp: Date.now()\n        })\n      });\n    } catch (error) {\n      logger.error('Failed to report permissions violation:', error);\n    }\n  }\n\n  /**\n   * Detect currently applied policies\n   */\n  detectCurrentPolicies() {\n    if (typeof document === 'undefined') return;\n    \n    try {\n      // Check if permissions policy API is available\n      if (document.permissionsPolicy) {\n        for (const directive of Object.keys(PERMISSIONS_DIRECTIVES)) {\n          try {\n            const allowed = document.permissionsPolicy.allowsFeature(directive);\n            this.appliedPolicies.set(directive, {\n              allowed,\n              origins: document.permissionsPolicy.getAllowlistForFeature(directive)\n            });\n          } catch (error) {\n            // Feature not supported or policy not set\n            logger.debug(`Feature ${directive} not available:`, error.message);\n          }\n        }\n      }\n    } catch (error) {\n      logger.warn('Failed to detect permissions policies:', error);\n    }\n  }\n\n  /**\n   * Monitor feature usage for compliance\n   */\n  monitorFeatureUsage() {\n    if (typeof window === 'undefined') return;\n    \n    // Monitor high-risk features\n    this.monitorCameraUsage();\n    this.monitorGeolocationUsage();\n    this.monitorExperimentalFeatures();\n  }\n\n  /**\n   * Monitor camera access\n   */\n  monitorCameraUsage() {\n    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {\n      const original = navigator.mediaDevices.getUserMedia;\n      \n      navigator.mediaDevices.getUserMedia = async function(constraints) {\n        logger.security({\n          type: 'camera_access_requested',\n          constraints,\n          timestamp: Date.now()\n        });\n        \n        try {\n          const stream = await original.call(this, constraints);\n          \n          logger.security({\n            type: 'camera_access_granted',\n            tracks: stream.getTracks().length,\n            timestamp: Date.now()\n          });\n          \n          return stream;\n        } catch (error) {\n          logger.security({\n            type: 'camera_access_denied',\n            error: error.name,\n            timestamp: Date.now()\n          });\n          throw error;\n        }\n      };\n    }\n  }\n\n  /**\n   * Monitor geolocation access\n   */\n  monitorGeolocationUsage() {\n    if (navigator.geolocation) {\n      const original = navigator.geolocation.getCurrentPosition;\n      \n      navigator.geolocation.getCurrentPosition = function(success, error, options) {\n        logger.security({\n          type: 'geolocation_access_requested',\n          options,\n          timestamp: Date.now()\n        });\n        \n        const wrappedSuccess = (position) => {\n          logger.security({\n            type: 'geolocation_access_granted',\n            accuracy: position.coords.accuracy,\n            timestamp: Date.now()\n          });\n          success(position);\n        };\n        \n        const wrappedError = (err) => {\n          logger.security({\n            type: 'geolocation_access_denied',\n            error: err.code,\n            timestamp: Date.now()\n          });\n          if (error) error(err);\n        };\n        \n        return original.call(this, wrappedSuccess, wrappedError, options);\n      };\n    }\n  }\n\n  /**\n   * Monitor experimental features\n   */\n  monitorExperimentalFeatures() {\n    // Monitor Topics API\n    if ('browsingTopics' in document) {\n      const original = document.browsingTopics;\n      \n      document.browsingTopics = async function() {\n        logger.security({\n          type: 'browsing_topics_accessed',\n          timestamp: Date.now()\n        });\n        \n        return original.call(this);\n      };\n    }\n    \n    // Monitor Attribution Reporting\n    if ('attribution' in window) {\n      logger.security({\n        type: 'attribution_reporting_available',\n        timestamp: Date.now()\n      });\n    }\n  }\n\n  /**\n   * Check if a feature is allowed\n   */\n  isFeatureAllowed(feature, origin = window.location.origin) {\n    if (typeof document === 'undefined') return true;\n    \n    try {\n      if (document.permissionsPolicy) {\n        return document.permissionsPolicy.allowsFeature(feature, origin);\n      }\n      \n      // Fallback to checking applied policies\n      const policy = this.appliedPolicies.get(feature);\n      return policy ? policy.allowed : true;\n    } catch (error) {\n      logger.warn(`Failed to check feature permission for ${feature}:`, error);\n      return false;\n    }\n  }\n\n  /**\n   * Get violation reports\n   */\n  getViolationReports() {\n    return [...this.violationReports];\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics() {\n    return {\n      supported: this.isSupported,\n      appliedPolicies: Object.fromEntries(this.appliedPolicies),\n      violationCount: this.violationReports.length,\n      lastViolation: this.violationReports[this.violationReports.length - 1],\n      experimentalFeaturesDetected: this.getExperimentalFeatures()\n    };\n  }\n\n  /**\n   * Get list of experimental features detected\n   */\n  getExperimentalFeatures() {\n    if (typeof window === 'undefined') return [];\n    \n    const experimental = [];\n    \n    if ('browsingTopics' in document) experimental.push('browsing-topics');\n    if ('attribution' in window) experimental.push('attribution-reporting');\n    if ('sharedStorage' in window) experimental.push('shared-storage');\n    if ('privateAggregation' in window) experimental.push('private-aggregation');\n    \n    return experimental;\n  }\n}\n\n// ============================================================================\n// MIDDLEWARE HELPERS\n// ============================================================================\n\n/**\n * Generate Permissions Policy header for a route\n */\nexport function generatePermissionsPolicyHeader(pathname) {\n  const routePolicy = getRoutePolicyConfig(pathname);\n  const directives = [];\n  \n  // Add route-specific policies\n  for (const [feature, allowlist] of Object.entries(routePolicy)) {\n    if (allowlist === 'none') {\n      directives.push(`${feature}=()`);\n    } else if (allowlist === 'self') {\n      directives.push(`${feature}=(self)`);\n    } else if (Array.isArray(allowlist)) {\n      const origins = allowlist.map(origin => \n        origin === 'self' ? 'self' : `\"${origin}\"`\n      ).join(' ');\n      directives.push(`${feature}=(${origins})`);\n    }\n  }\n  \n  // Add default restrictions for unspecified high-risk features\n  const highRiskFeatures = Object.entries(PERMISSIONS_DIRECTIVES)\n    .filter(([, config]) => config.riskLevel === 'high')\n    .map(([feature]) => feature)\n    .filter(feature => !routePolicy[feature]);\n  \n  for (const feature of highRiskFeatures) {\n    directives.push(`${feature}=()`);\n  }\n  \n  const header = directives.join(', ');\n  \n  logger.debug('Generated Permissions Policy header:', {\n    pathname,\n    header,\n    directiveCount: directives.length\n  });\n  \n  return header;\n}\n\n/**\n * Get route policy configuration\n */\nfunction getRoutePolicyConfig(pathname) {\n  // Check for exact route matches\n  for (const [route, policy] of Object.entries(ROUTE_POLICIES)) {\n    if (pathname === route || pathname.startsWith(route + '/')) {\n      return policy;\n    }\n  }\n  \n  // Default restrictive policy\n  return {\n    camera: 'none',\n    microphone: 'none',\n    geolocation: 'none',\n    'attribution-reporting': 'none',\n    'browsing-topics': 'none'\n  };\n}\n\n/**\n * Add Permissions Policy headers to response\n */\nexport function addPermissionsPolicyHeaders(response, pathname) {\n  const header = generatePermissionsPolicyHeader(pathname);\n  \n  if (header) {\n    response.headers.set('Permissions-Policy', header);\n  }\n  \n  return response;\n}\n\n// ============================================================================\n// REACT INTEGRATION\n// ============================================================================\n\n/**\n * React hook for permissions policy\n */\nexport function usePermissionsPolicy() {\n  const manager = getPermissionsPolicyManager();\n  \n  return {\n    isSupported: manager.isSupported,\n    isFeatureAllowed: (feature, origin) => manager.isFeatureAllowed(feature, origin),\n    metrics: manager.getMetrics(),\n    violationReports: manager.getViolationReports()\n  };\n}\n\n/**\n * Component that only renders if a feature is allowed\n */\nexport function PermissionGatedFeature({ feature, children, fallback = null, origin }) {\n  const { isFeatureAllowed } = usePermissionsPolicy();\n  \n  if (!isFeatureAllowed(feature, origin)) {\n    return fallback;\n  }\n  \n  return children;\n}\n\n/**\n * Safe feature accessor component\n */\nexport function SafeFeatureAccess({ feature, onAccess, onDenied, children }) {\n  const { isFeatureAllowed } = usePermissionsPolicy();\n  \n  const handleAccess = async () => {\n    if (!isFeatureAllowed(feature)) {\n      if (onDenied) onDenied();\n      return;\n    }\n    \n    if (onAccess) {\n      try {\n        await onAccess();\n      } catch (error) {\n        logger.error(`Feature access failed for ${feature}:`, error);\n        if (onDenied) onDenied(error);\n      }\n    }\n  };\n  \n  return React.cloneElement(children, { onClick: handleAccess });\n}\n\n// ============================================================================\n// GLOBAL INSTANCE\n// ============================================================================\n\nlet permissionsPolicyManagerInstance = null;\n\nexport function getPermissionsPolicyManager() {\n  if (!permissionsPolicyManagerInstance) {\n    permissionsPolicyManagerInstance = new PermissionsPolicyManager();\n  }\n  return permissionsPolicyManagerInstance;\n}\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n/**\n * Initialize permissions policy monitoring\n */\nexport function initializePermissionsPolicy() {\n  const manager = getPermissionsPolicyManager();\n  manager.initialize();\n}\n\n// Auto-initialize in browser environment\nif (typeof window !== 'undefined') {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', initializePermissionsPolicy);\n  } else {\n    initializePermissionsPolicy();\n  }\n}\n\nexport default getPermissionsPolicyManager;

/**
 * ðŸ”¬ EXPERIMENTAL: Advanced Security Middleware
 * Next.js 15+ Security Implementation (2024-2025)
 *
 * Integrates all experimental security features and addresses recent vulnerabilities
 * including CVE-2025-29927 (middleware bypass) and other cutting-edge threats.
 *
 * @see https://nextjs.org/docs/app/building-your-application/routing/middleware
 * @see https://vercel.com/blog/postmortem-on-next-js-middleware-bypass
 */

import { NextResponse } from "next/server";
import { logger } from "@/lib/utils/logger";
import { getTrustedTypesCSP } from "./trusted-types";
import { generateIsolationHeaders } from "./cross-origin-isolation";
import { generateDocumentIsolationHeader } from "./document-isolation-policy";
import { generatePermissionsPolicyHeader } from "./permissions-policy";

// ============================================================================\n// SECURITY CONFIGURATION\n// ============================================================================\n\n/**\n * Advanced security configuration\n */\nconst SECURITY_CONFIG = {\n  // CVE-2025-29927 Protection\n  middlewareBypassProtection: {\n    enabled: true,\n    logSuspiciousHeaders: true,\n    blockMalformedHeaders: true,\n    alertThreshold: 5 // Alert after 5 blocked attempts\n  },\n  \n  // Security headers configuration\n  headers: {\n    // Basic security headers\n    basic: {\n      'X-Frame-Options': 'DENY',\n      'X-Content-Type-Options': 'nosniff',\n      'X-XSS-Protection': '1; mode=block',\n      'Referrer-Policy': 'strict-origin-when-cross-origin',\n      'X-DNS-Prefetch-Control': 'off',\n      'X-Download-Options': 'noopen',\n      'X-Permitted-Cross-Domain-Policies': 'none'\n    },\n    \n    // HTTPS enforcement\n    https: {\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload'\n    },\n    \n    // Experimental security headers\n    experimental: {\n      'Cross-Origin-Resource-Policy': 'cross-origin',\n      'Origin-Agent-Cluster': '?1',\n      'Sec-Fetch-Site': 'same-origin',\n      'Timing-Allow-Origin': '*'\n    }\n  },\n  \n  // Rate limiting\n  rateLimiting: {\n    enabled: true,\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    maxRequests: {\n      default: 1000,\n      api: 500,\n      auth: 100,\n      admin: 50\n    }\n  },\n  \n  // Request validation\n  validation: {\n    maxHeaderSize: 8192, // 8KB\n    maxBodySize: 1024 * 1024, // 1MB\n    allowedMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n    requiredHeaders: ['user-agent']\n  },\n  \n  // Bot detection\n  botDetection: {\n    enabled: true,\n    suspiciousPatterns: [\n      /crawl|spider|bot|scraper/i,\n      /curl|wget|postman/i,\n      /python|node|go-http/i\n    ],\n    allowedBots: [\n      'Googlebot',\n      'Bingbot',\n      'Slackbot',\n      'facebookexternalhit'\n    ]\n  },\n  \n  // Security monitoring\n  monitoring: {\n    logAllRequests: process.env.NODE_ENV === 'development',\n    logSecurityEvents: true,\n    alertOnSuspiciousActivity: true,\n    metricsCollection: true\n  }\n};\n\n/**\n * Route-specific security profiles\n */\nconst ROUTE_SECURITY_PROFILES = {\n  // Public routes - basic security\n  public: {\n    routes: ['/', '/about', '/contact', '/blog'],\n    security: 'basic',\n    rateLimit: 'default',\n    botAllowed: true\n  },\n  \n  // API routes - enhanced security\n  api: {\n    routes: ['/api'],\n    security: 'enhanced',\n    rateLimit: 'api',\n    botAllowed: false,\n    requireAuth: false\n  },\n  \n  // Authentication routes - high security\n  auth: {\n    routes: ['/auth', '/login', '/register'],\n    security: 'high',\n    rateLimit: 'auth',\n    botAllowed: false,\n    requireCSRF: true\n  },\n  \n  // Admin routes - maximum security\n  admin: {\n    routes: ['/admin'],\n    security: 'maximum',\n    rateLimit: 'admin',\n    botAllowed: false,\n    requireAuth: true,\n    requireMFA: true\n  },\n  \n  // Dashboard - enhanced security\n  dashboard: {\n    routes: ['/dashboard'],\n    security: 'enhanced',\n    rateLimit: 'default',\n    botAllowed: false,\n    requireAuth: true\n  }\n};\n\n// ============================================================================\n// MIDDLEWARE BYPASS PROTECTION (CVE-2025-29927)\n// ============================================================================\n\n/**\n * Detect and prevent middleware bypass attempts\n */\nfunction detectMiddlewareBypass(request) {\n  const suspiciousHeaders = [];\n  const alertReasons = [];\n  \n  // Check for malicious x-middleware-subrequest header\n  const middlewareHeader = request.headers.get('x-middleware-subrequest');\n  if (middlewareHeader) {\n    // Check for suspicious patterns that could bypass middleware\n    const suspiciousPatterns = [\n      /middleware:middleware/,\n      /src\\/middleware:src\\/middleware/,\n      /(middleware:){3,}/,\n      /(src\\/middleware:){3,}/,\n      /[\\x00-\\x1f\\x7f-\\x9f]/, // Control characters\n      /.{100,}/ // Excessively long values\n    ];\n    \n    for (const pattern of suspiciousPatterns) {\n      if (pattern.test(middlewareHeader)) {\n        suspiciousHeaders.push({\n          name: 'x-middleware-subrequest',\n          value: middlewareHeader.substring(0, 100), // Limit logged value\n          pattern: pattern.source,\n          risk: 'high'\n        });\n        alertReasons.push(`Malicious middleware header detected: ${pattern.source}`);\n        break;\n      }\n    }\n  }\n  \n  // Check for other suspicious headers\n  const otherSuspiciousHeaders = [\n    'x-middleware-invoke',\n    'x-middleware-next',\n    'x-middleware-override',\n    'x-nextjs-bypass',\n    'x-internal-route'\n  ];\n  \n  for (const headerName of otherSuspiciousHeaders) {\n    const headerValue = request.headers.get(headerName);\n    if (headerValue) {\n      suspiciousHeaders.push({\n        name: headerName,\n        value: headerValue.substring(0, 100),\n        risk: 'medium'\n      });\n      alertReasons.push(`Suspicious internal header: ${headerName}`);\n    }\n  }\n  \n  // Check for header injection attempts\n  const allHeaders = Object.fromEntries(request.headers.entries());\n  for (const [name, value] of Object.entries(allHeaders)) {\n    if (value.includes('\\n') || value.includes('\\r')) {\n      suspiciousHeaders.push({\n        name,\n        value: value.substring(0, 50),\n        risk: 'high'\n      });\n      alertReasons.push(`Header injection attempt in: ${name}`);\n    }\n  }\n  \n  return {\n    isSuspicious: suspiciousHeaders.length > 0,\n    suspiciousHeaders,\n    alertReasons,\n    riskLevel: suspiciousHeaders.some(h => h.risk === 'high') ? 'high' : 'medium'\n  };\n}\n\n/**\n * Sanitize headers to prevent bypass attempts\n */\nfunction sanitizeHeaders(request) {\n  const sanitizedHeaders = new Headers(request.headers);\n  \n  // Remove potentially dangerous headers\n  const dangerousHeaders = [\n    'x-middleware-subrequest',\n    'x-middleware-invoke',\n    'x-middleware-next',\n    'x-middleware-override',\n    'x-nextjs-bypass',\n    'x-internal-route'\n  ];\n  \n  for (const header of dangerousHeaders) {\n    if (sanitizedHeaders.has(header)) {\n      logger.security({\n        type: 'header_sanitized',\n        header,\n        value: sanitizedHeaders.get(header)?.substring(0, 100),\n        url: request.url,\n        timestamp: Date.now()\n      });\n      sanitizedHeaders.delete(header);\n    }\n  }\n  \n  return sanitizedHeaders;\n}\n\n// ============================================================================\n// SECURITY VALIDATORS\n// ============================================================================\n\n/**\n * Validate request structure and headers\n */\nfunction validateRequest(request) {\n  const validation = {\n    isValid: true,\n    errors: [],\n    warnings: []\n  };\n  \n  // Check method\n  if (!SECURITY_CONFIG.validation.allowedMethods.includes(request.method)) {\n    validation.isValid = false;\n    validation.errors.push(`Invalid HTTP method: ${request.method}`);\n  }\n  \n  // Check required headers\n  for (const header of SECURITY_CONFIG.validation.requiredHeaders) {\n    if (!request.headers.get(header)) {\n      validation.warnings.push(`Missing recommended header: ${header}`);\n    }\n  }\n    \n  // Check header sizes\n  let totalHeaderSize = 0;\n  for (const [name, value] of request.headers.entries()) {\n    totalHeaderSize += name.length + value.length;\n  }\n  \n  if (totalHeaderSize > SECURITY_CONFIG.validation.maxHeaderSize) {\n    validation.isValid = false;\n    validation.errors.push(`Headers too large: ${totalHeaderSize} bytes`);\n  }\n  \n  // Check URL length\n  if (request.url.length > 2048) {\n    validation.warnings.push(`Long URL detected: ${request.url.length} characters`);\n  }\n  \n  return validation;\n}\n\n/**\n * Detect bot and automated requests\n */\nfunction detectBot(request) {\n  const userAgent = request.headers.get('user-agent') || '';\n  const botDetection = {\n    isBot: false,\n    type: 'human',\n    confidence: 0,\n    allowedBot: false\n  };\n  \n  // Check against suspicious patterns\n  for (const pattern of SECURITY_CONFIG.botDetection.suspiciousPatterns) {\n    if (pattern.test(userAgent)) {\n      botDetection.isBot = true;\n      botDetection.confidence = 0.8;\n      botDetection.type = 'suspicious';\n      break;\n    }\n  }\n  \n  // Check against allowed bots\n  for (const allowedBot of SECURITY_CONFIG.botDetection.allowedBots) {\n    if (userAgent.includes(allowedBot)) {\n      botDetection.isBot = true;\n      botDetection.allowedBot = true;\n      botDetection.confidence = 0.9;\n      botDetection.type = 'allowed';\n      break;\n    }\n  }\n  \n  // Additional bot indicators\n  const botIndicators = [\n    !request.headers.get('accept'),\n    !request.headers.get('accept-language'),\n    !request.headers.get('accept-encoding'),\n    request.headers.get('connection') === 'close'\n  ];\n  \n  const indicatorCount = botIndicators.filter(Boolean).length;\n  if (indicatorCount >= 2 && !botDetection.allowedBot) {\n    botDetection.isBot = true;\n    botDetection.confidence = Math.min(0.7, 0.2 * indicatorCount);\n    botDetection.type = 'suspected';\n  }\n  \n  return botDetection;\n}\n\n// ============================================================================\n// RATE LIMITING\n// ============================================================================\n\nconst rateLimitStore = new Map();\n\n/**\n * Apply rate limiting based on route profile\n */\nfunction applyRateLimit(request, profile) {\n  if (!SECURITY_CONFIG.rateLimiting.enabled) return { allowed: true };\n  \n  const clientIP = getClientIP(request);\n  const windowMs = SECURITY_CONFIG.rateLimiting.windowMs;\n  const maxRequests = SECURITY_CONFIG.rateLimiting.maxRequests[profile.rateLimit];\n  \n  const now = Date.now();\n  const windowStart = now - windowMs;\n  \n  // Get or create rate limit entry\n  const key = `${clientIP}:${profile.rateLimit}`;\n  let entry = rateLimitStore.get(key);\n  \n  if (!entry) {\n    entry = { requests: [], createdAt: now };\n    rateLimitStore.set(key, entry);\n  }\n  \n  // Remove old requests outside the window\n  entry.requests = entry.requests.filter(timestamp => timestamp > windowStart);\n  \n  // Check if limit exceeded\n  if (entry.requests.length >= maxRequests) {\n    logger.security({\n      type: 'rate_limit_exceeded',\n      clientIP,\n      profile: profile.rateLimit,\n      requestCount: entry.requests.length,\n      maxRequests,\n      timestamp: now\n    });\n    \n    return {\n      allowed: false,\n      remaining: 0,\n      resetTime: Math.min(...entry.requests) + windowMs\n    };\n  }\n  \n  // Add current request\n  entry.requests.push(now);\n  \n  return {\n    allowed: true,\n    remaining: maxRequests - entry.requests.length,\n    resetTime: now + windowMs\n  };\n}\n\n/**\n * Get client IP address\n */\nfunction getClientIP(request) {\n  // Check various headers for real IP\n  const headers = [\n    'x-forwarded-for',\n    'x-real-ip',\n    'x-client-ip',\n    'cf-connecting-ip', // Cloudflare\n    'x-vercel-forwarded-for' // Vercel\n  ];\n  \n  for (const header of headers) {\n    const value = request.headers.get(header);\n    if (value) {\n      // Take first IP if comma-separated\n      return value.split(',')[0].trim();\n    }\n  }\n  \n  return 'unknown';\n}\n\n// ============================================================================\n// SECURITY PROFILE DETERMINATION\n// ============================================================================\n\n/**\n * Determine security profile for a route\n */\nfunction getSecurityProfile(pathname) {\n  for (const [profileName, config] of Object.entries(ROUTE_SECURITY_PROFILES)) {\n    for (const route of config.routes) {\n      if (pathname === route || pathname.startsWith(route + '/')) {\n        return { name: profileName, ...config };\n      }\n    }\n  }\n  \n  // Default to public profile\n  return { name: 'public', ...ROUTE_SECURITY_PROFILES.public };\n}\n\n// ============================================================================\n// COMPREHENSIVE SECURITY HEADERS\n// ============================================================================\n\n/**\n * Generate all security headers for a request\n */\nfunction generateSecurityHeaders(request, profile) {\n  const url = new URL(request.url);\n  const headers = new Headers();\n  \n  // Basic security headers\n  for (const [name, value] of Object.entries(SECURITY_CONFIG.headers.basic)) {\n    headers.set(name, value);\n  }\n  \n  // HTTPS headers (only for HTTPS)\n  if (url.protocol === 'https:' || process.env.NODE_ENV === 'production') {\n    for (const [name, value] of Object.entries(SECURITY_CONFIG.headers.https)) {\n      headers.set(name, value);\n    }\n  }\n  \n  // Experimental headers\n  for (const [name, value] of Object.entries(SECURITY_CONFIG.headers.experimental)) {\n    headers.set(name, value);\n  }\n  \n  // Content Security Policy with Trusted Types\n  const trustedTypesCSP = getTrustedTypesCSP();\n  const cspDirectives = [\n    \"default-src 'self'\",\n    \"script-src 'self' 'unsafe-inline' 'unsafe-eval'\",\n    \"style-src 'self' 'unsafe-inline'\",\n    \"img-src 'self' data: https:\",\n    \"font-src 'self' https:\",\n    \"connect-src 'self' https:\",\n    \"frame-ancestors 'none'\",\n    \"base-uri 'self'\",\n    \"form-action 'self'\"\n  ];\n  \n  // Add Trusted Types directives\n  for (const [directive, values] of Object.entries(trustedTypesCSP)) {\n    cspDirectives.push(`${directive} ${values.join(' ')}`);\n  }\n  \n  headers.set('Content-Security-Policy', cspDirectives.join('; '));\n  \n  // Cross-Origin Isolation headers\n  const isolationHeaders = generateIsolationHeaders(url.pathname);\n  for (const [name, value] of Object.entries(isolationHeaders)) {\n    headers.set(name, value);\n  }\n  \n  // Document Isolation Policy (experimental)\n  const dipHeaders = generateDocumentIsolationHeader(url.pathname);\n  for (const [name, value] of Object.entries(dipHeaders)) {\n    headers.set(name, value);\n  }\n  \n  // Permissions Policy\n  const permissionsPolicy = generatePermissionsPolicyHeader(url.pathname);\n  if (permissionsPolicy) {\n    headers.set('Permissions-Policy', permissionsPolicy);\n  }\n  \n  return headers;\n}\n\n// ============================================================================\n// MAIN MIDDLEWARE FUNCTION\n// ============================================================================\n\n/**\n * Advanced security middleware\n */\nexport async function advancedSecurityMiddleware(request) {\n  const startTime = Date.now();\n  const url = new URL(request.url);\n  const clientIP = getClientIP(request);\n  \n  // Log request if configured\n  if (SECURITY_CONFIG.monitoring.logAllRequests) {\n    logger.debug('Request received:', {\n      method: request.method,\n      url: url.pathname,\n      ip: clientIP,\n      userAgent: request.headers.get('user-agent')?.substring(0, 100)\n    });\n  }\n  \n  // 1. Detect middleware bypass attempts (CVE-2025-29927)\n  const bypassDetection = detectMiddlewareBypass(request);\n  if (bypassDetection.isSuspicious && SECURITY_CONFIG.middlewareBypassProtection.blockMalformedHeaders) {\n    logger.critical({\n      type: 'middleware_bypass_attempt',\n      ip: clientIP,\n      url: url.pathname,\n      suspiciousHeaders: bypassDetection.suspiciousHeaders,\n      alertReasons: bypassDetection.alertReasons,\n      riskLevel: bypassDetection.riskLevel,\n      timestamp: Date.now()\n    });\n    \n    return new NextResponse('Security violation detected', { \n      status: 403,\n      headers: {\n        'X-Security-Block': 'middleware-bypass-protection',\n        'Retry-After': '3600' // 1 hour\n      }\n    });\n  }\n  \n  // 2. Validate request structure\n  const validation = validateRequest(request);\n  if (!validation.isValid) {\n    logger.security({\n      type: 'request_validation_failed',\n      ip: clientIP,\n      url: url.pathname,\n      errors: validation.errors,\n      timestamp: Date.now()\n    });\n    \n    return new NextResponse('Invalid request', { status: 400 });\n  }\n  \n  // 3. Determine security profile\n  const profile = getSecurityProfile(url.pathname);\n  \n  // 4. Bot detection\n  const botDetection = detectBot(request);\n  if (botDetection.isBot && !botDetection.allowedBot && !profile.botAllowed) {\n    logger.security({\n      type: 'bot_blocked',\n      ip: clientIP,\n      url: url.pathname,\n      botType: botDetection.type,\n      confidence: botDetection.confidence,\n      userAgent: request.headers.get('user-agent'),\n      timestamp: Date.now()\n    });\n    \n    return new NextResponse('Access denied', { \n      status: 403,\n      headers: { 'X-Security-Block': 'bot-protection' }\n    });\n  }\n  \n  // 5. Rate limiting\n  const rateLimitResult = applyRateLimit(request, profile);\n  if (!rateLimitResult.allowed) {\n    return new NextResponse('Rate limit exceeded', {\n      status: 429,\n      headers: {\n        'Retry-After': Math.ceil((rateLimitResult.resetTime - Date.now()) / 1000).toString(),\n        'X-RateLimit-Remaining': '0',\n        'X-RateLimit-Reset': rateLimitResult.resetTime.toString()\n      }\n    });\n  }\n  \n  // 6. Sanitize headers\n  const sanitizedHeaders = sanitizeHeaders(request);\n  \n  // 7. Generate security headers\n  const securityHeaders = generateSecurityHeaders(request, profile);\n  \n  // 8. Create response with security headers\n  const response = NextResponse.next({\n    request: {\n      headers: sanitizedHeaders\n    }\n  });\n  \n  // Add all security headers\n  for (const [name, value] of securityHeaders.entries()) {\n    response.headers.set(name, value);\n  }\n  \n  // Add rate limit headers\n  if (rateLimitResult.remaining !== undefined) {\n    response.headers.set('X-RateLimit-Remaining', rateLimitResult.remaining.toString());\n    response.headers.set('X-RateLimit-Reset', rateLimitResult.resetTime.toString());\n  }\n  \n  // Add security context headers\n  response.headers.set('X-Security-Profile', profile.name);\n  response.headers.set('X-Bot-Detection', botDetection.isBot ? botDetection.type : 'human');\n  \n  // Log security metrics\n  const processingTime = Date.now() - startTime;\n  if (SECURITY_CONFIG.monitoring.metricsCollection) {\n    logger.performance({\n      type: 'security_middleware_metrics',\n      processingTime,\n      profile: profile.name,\n      bypassAttempt: bypassDetection.isSuspicious,\n      botDetected: botDetection.isBot,\n      rateLimited: !rateLimitResult.allowed,\n      timestamp: Date.now()\n    });\n  }\n  \n  return response;\n}\n\nexport default advancedSecurityMiddleware;

---
alwaysApply: true
description: Performance-first development with enterprise-level monitoring and logging
---

# Performance-First Development & Enterprise Monitoring

## üöÄ PERFORMANCE IS PRIORITY #1

**ALL CODE DECISIONS MUST PRIORITIZE PERFORMANCE AND SPEED ABOVE EVERYTHING ELSE**

### Core Performance Principles (Google/Netflix/Meta Standards)

1. **Speed Over Features**: If a feature impacts performance, performance wins
2. **Measure First**: No optimization without measurement
3. **Budget-Driven Development**: Strict performance budgets for everything
4. **Zero Tolerance**: Sub-optimal code should not reach production

## üìä Comprehensive Logging Strategy (Enterprise-Level)

### Performance Metrics (Netflix-Style)
```javascript
// ALWAYS implement these metrics in every component
const performanceMetrics = {
  // Core Web Vitals (Google Standard)
  LCP: 'target: <2.5s, budget: <4s',
  FID: 'target: <100ms, budget: <300ms', 
  CLS: 'target: <0.1, budget: <0.25',
  
  // Custom Business Metrics (Meta/Netflix Style)
  timeToInteractive: 'target: <3s',
  firstContentfulPaint: 'target: <1.8s',
  totalBlockingTime: 'target: <200ms',
  serverResponseTime: 'target: <200ms',
  bundleSize: 'target: <250KB initial, <100KB chunks',
  
  // User Experience Metrics (Airbnb Style)
  clickToNavigation: 'target: <100ms',
  scrollResponsiveness: 'target: 60fps',
  imageLoadTime: 'target: <2s',
  searchResponseTime: 'target: <300ms'
};
```

### Extensive Logging Framework (Multi-Level)

#### 1. Performance Logging (Always Required)
```javascript
// Every function/component MUST include performance tracking
const performanceLogger = {
  startTime: performance.now(),
  
  // Log function execution time
  trackExecution: (functionName, startTime) => {
    const duration = performance.now() - startTime;
    logger.performance(`${functionName} executed in ${duration.toFixed(2)}ms`);
    
    // Alert if exceeds budget
    if (duration > PERFORMANCE_BUDGET[functionName]) {
      logger.critical(`PERFORMANCE VIOLATION: ${functionName} exceeded budget by ${duration - PERFORMANCE_BUDGET[functionName]}ms`);
    }
  },
  
  // Track component render time
  trackRender: (componentName, renderTime) => {
    logger.performance(`${componentName} rendered in ${renderTime}ms`);
  }
};
```

#### 2. User Interaction Logging (Amazon/Google Level)
```javascript
// Track EVERY user interaction with detailed context
const interactionLogger = {
  click: (element, context) => {
    logger.interaction({
      type: 'click',
      element: element.tagName + (element.className ? `.${element.className}` : ''),
      timestamp: Date.now(),
      userAgent: navigator.userAgent,
      viewport: `${window.innerWidth}x${window.innerHeight}`,
      scrollPosition: window.scrollY,
      context: context,
      responseTime: performance.now() - clickStartTime
    });
  },
  
  error: (error, context) => {
    logger.error({
      message: error.message,
      stack: error.stack,
      component: context.component,
      props: context.props,
      state: context.state,
      userActions: getUserActionHistory(),
      browserInfo: getBrowserInfo(),
      timestamp: Date.now()
    });
  }
};
```

#### 3. Business Intelligence Logging (Meta/Netflix Style)
```javascript
// Track business metrics for data-driven decisions
const businessLogger = {
  searchPerformance: {
    query: searchTerm,
    resultsCount: results.length,
    responseTime: searchDuration,
    userLocation: userLocation,
    filters: appliedFilters,
    clickThroughRate: calculateCTR(),
    abandonmentRate: calculateAbandonmentRate()
  },
  
  userJourney: {
    sessionId: generateSessionId(),
    pageViews: trackPageViews(),
    timeOnSite: calculateTimeOnSite(),
    bounceRate: calculateBounceRate(),
    conversionEvents: trackConversions()
  }
};
```

## üèóÔ∏è Performance Architecture Requirements

### 1. Component-Level Performance (React/Next.js Best Practices)
```javascript
// EVERY component must follow these patterns

// ‚úÖ REQUIRED: Memoization for expensive computations
const ExpensiveComponent = memo(({ data }) => {
  const processedData = useMemo(() => 
    heavyComputation(data), [data]
  );
  
  const optimizedCallback = useCallback((item) => 
    handleItemClick(item), [dependency]
  );
  
  return <OptimizedUI data={processedData} onClick={optimizedCallback} />;
});

// ‚úÖ REQUIRED: Performance measurement wrapper
const withPerformanceTracking = (Component) => {
  return (props) => {
    const startTime = performance.now();
    
    useEffect(() => {
      const renderTime = performance.now() - startTime;
      logger.performance(`${Component.name} render time: ${renderTime}ms`);
    }, []);
    
    return <Component {...props} />;
  };
};
```

### 2. API Performance (Stripe/Shopify Standards)
```javascript
// ALL API calls must include comprehensive monitoring
const apiPerformanceWrapper = async (apiCall, endpoint) => {
  const startTime = performance.now();
  const requestId = generateRequestId();
  
  logger.api({
    requestId,
    endpoint,
    method: apiCall.method,
    payload: apiCall.body,
    timestamp: Date.now(),
    userAgent: navigator.userAgent
  });
  
  try {
    const response = await apiCall();
    const duration = performance.now() - startTime;
    
    logger.api({
      requestId,
      status: 'success',
      statusCode: response.status,
      responseTime: duration,
      responseSize: JSON.stringify(response.data).length,
      cacheHit: response.headers['x-cache-status']
    });
    
    return response;
  } catch (error) {
    logger.api({
      requestId,
      status: 'error',
      error: error.message,
      responseTime: performance.now() - startTime
    });
    throw error;
  }
};
```

### 3. Bundle Optimization (Webpack/Next.js Production Config)
```javascript
// MANDATORY: Bundle analysis and optimization
module.exports = {
  webpack: (config, { dev, isServer }) => {
    // Performance budgets (Enforced)
    config.performance = {
      maxAssetSize: 250000,      // 250KB max asset size
      maxEntrypointSize: 500000, // 500KB max entry point
      hints: 'error'             // Fail build if exceeded
    };
    
    // Code splitting (Required for all routes)
    config.optimization = {
      splitChunks: {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            chunks: 'all',
            maxSize: 100000 // 100KB chunks max
          }
        }
      }
    };
    
    return config;
  }
};
```

## üîç Advanced Monitoring Implementation

### 1. Real-Time Performance Dashboard
```javascript
// Create performance monitoring dashboard
const PerformanceMonitor = {
  realTimeMetrics: {
    activeUsers: trackActiveUsers(),
    serverLoad: trackServerLoad(),
    errorRate: calculateErrorRate(),
    responseTime: getAverageResponseTime(),
    throughput: calculateThroughput()
  },
  
  alerts: {
    performanceDegradation: threshold => {
      if (responseTime > threshold) {
        sendAlert('PERFORMANCE_DEGRADATION', {
          currentResponseTime: responseTime,
          threshold: threshold,
          affectedUsers: getAffectedUsers()
        });
      }
    }
  }
};
```

### 2. Error Tracking & Recovery (Sentry/Bugsnag Level)
```javascript
// Comprehensive error tracking with context
const errorTracker = {
  captureError: (error, context) => {
    const errorDetails = {
      errorId: generateErrorId(),
      message: error.message,
      stack: error.stack,
      component: context.component,
      props: sanitizeProps(context.props),
      state: sanitizeState(context.state),
      userAgent: navigator.userAgent,
      url: window.location.href,
      timestamp: Date.now(),
      userId: getCurrentUserId(),
      sessionId: getSessionId(),
      buildVersion: process.env.BUILD_VERSION,
      releaseStage: process.env.NODE_ENV
    };
    
    // Log locally
    logger.error(errorDetails);
    
    // Send to external service
    sendToErrorService(errorDetails);
    
    // Trigger recovery mechanisms
    triggerErrorRecovery(error, context);
  }
};
```

## üìà Performance Testing & Validation

### 1. Automated Performance Testing
```bash
# REQUIRED: Performance tests in CI/CD
npm run test:performance    # Lighthouse CI
npm run test:load          # Load testing
npm run test:bundle        # Bundle size analysis
npm run test:accessibility # a11y performance
```

### 2. Performance Gates (No Deploy Without Passing)
```javascript
// Performance gates that must pass before deployment
const performanceGates = {
  lighthouse: {
    performance: 90,
    accessibility: 100,
    bestPractices: 100,
    seo: 100
  },
  
  webVitals: {
    LCP: 2.5,
    FID: 0.1,
    CLS: 0.1
  },
  
  bundleSize: {
    mainBundle: 250, // KB
    chunkSize: 100   // KB
  }
};
```

## üõ†Ô∏è Development Workflow (Performance-First)

### 1. Code Review Checklist
- [ ] Performance impact measured and documented
- [ ] Appropriate caching strategy implemented
- [ ] Error boundaries added for critical paths
- [ ] Comprehensive logging added
- [ ] Bundle size impact assessed
- [ ] Accessibility performance verified
- [ ] Mobile performance tested

### 2. Performance Budget Enforcement
```javascript
// Enforce performance budgets in development
const performanceBudgets = {
  // Time budgets (milliseconds)
  componentRender: 16,     // 60fps target
  apiResponse: 300,        // User expectation
  pageLoad: 3000,          // Business requirement
  
  // Size budgets (bytes)
  imageSize: 100000,       // 100KB max
  jsBundle: 250000,        // 250KB max
  cssBundle: 50000,        // 50KB max
  
  // Quality budgets
  errorRate: 0.001,        // 0.1% max error rate
  crashRate: 0.0001        // 0.01% max crash rate
};
```

## üîß Implementation Guidelines

### Always Use:
1. **[lib/utils/webVitals.js](mdc:lib/utils/webVitals.js)** - For Core Web Vitals tracking
2. **[lib/utils/cacheManager.js](mdc:lib/utils/cacheManager.js)** - For intelligent caching
3. **[lib/utils/errorHandler.js](mdc:lib/utils/errorHandler.js)** - For comprehensive error handling
4. **[lib/utils/logger.js](mdc:lib/utils/logger.js)** - For structured logging
5. **[components/shared/ErrorBoundaryWrapper.js](mdc:components/shared/ErrorBoundaryWrapper.js)** - For error isolation

### Never Do:
- Ship code without performance measurement
- Ignore bundle size increases
- Skip error handling
- Deploy without logging
- Compromise Core Web Vitals for features

### Performance-First Mindset:
Every line of code should ask: "How does this impact performance?"
Every feature should justify its performance cost.
Every optimization should be measured and validated.

**Remember: Users will forgive missing features but not slow performance.**

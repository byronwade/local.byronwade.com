---
globs: "lib/supabase/security/**/*,**/validation.ts,**/encryption.ts,**/policies.sql"
description: Comprehensive Supabase security implementation with data validation and encryption
---

# Supabase Security & Data Protection

## ðŸ›¡ï¸ ZERO-TRUST SECURITY ARCHITECTURE

**ALL DATA OPERATIONS MUST BE VALIDATED, ENCRYPTED, AND AUDITED**

### Data Validation Schema ([lib/supabase/security/validation.ts](mdc:lib/supabase/security/validation.ts))

```typescript
// REQUIRED: Comprehensive data validation with performance optimization
import { z } from 'zod';
import { logger } from '@lib/utils/logger';

/**
 * High-performance validation schemas with security focus
 * Implements input sanitization and business rule validation
 */

// Base validation utilities
const sanitizeString = (str: string): string => {
  return str
    .trim()
    .replace(/[<>]/g, '') // Remove potential XSS characters
    .slice(0, 1000); // Limit length to prevent DoS
};

const validateUUID = z.string().uuid();
const validateEmail = z.string().email().max(254);
const validatePhone = z.string().regex(/^\+?[\d\s\-\(\)]{10,20}$/);
const validateURL = z.string().url().max(500);

// Business entity validation schemas
export const BusinessValidation = {
  // Business registration validation
  create: z.object({
    name: z.string()
      .min(2, 'Business name must be at least 2 characters')
      .max(100, 'Business name must be less than 100 characters')
      .transform(sanitizeString),
    
    description: z.string()
      .min(10, 'Description must be at least 10 characters')
      .max(2000, 'Description must be less than 2000 characters')
      .transform(sanitizeString),
    
    email: validateEmail,
    phone: validatePhone.optional(),
    website: validateURL.optional(),
    
    address: z.object({
      street: z.string().min(5).max(200).transform(sanitizeString),
      city: z.string().min(2).max(100).transform(sanitizeString),
      state: z.string().min(2).max(100).transform(sanitizeString),
      zip: z.string().regex(/^\d{5}(-\d{4})?$/),
      country: z.string().default('US'),
    }),
    
    coordinates: z.object({
      latitude: z.number().min(-90).max(90),
      longitude: z.number().min(-180).max(180),
    }),
    
    categories: z.array(validateUUID).min(1).max(10),
    
    hours: z.object({
      monday: z.object({
        open: z.string().regex(/^\d{2}:\d{2}$/),
        close: z.string().regex(/^\d{2}:\d{2}$/),
        closed: z.boolean().default(false),
      }),
      // ... repeat for other days
    }).optional(),
    
    amenities: z.array(z.string()).max(20),
    payment_methods: z.array(z.string()).max(10),
    
    // Security metadata
    owner_verification: z.object({
      document_type: z.enum(['drivers_license', 'passport', 'business_license']),
      document_number: z.string().transform(sanitizeString),
      verification_status: z.enum(['pending', 'verified', 'rejected']).default('pending'),
    }),
  }).strict(), // Reject unknown properties for security

  // Business update validation (partial)
  update: z.object({
    name: z.string().min(2).max(100).transform(sanitizeString).optional(),
    description: z.string().min(10).max(2000).transform(sanitizeString).optional(),
    phone: validatePhone.optional(),
    website: validateURL.optional(),
    // ... other updatable fields
  }).strict(),

  // Business search validation
  search: z.object({
    query: z.string().max(200).transform(sanitizeString).optional(),
    location: z.string().max(200).transform(sanitizeString).optional(),
    category: validateUUID.optional(),
    bounds: z.object({
      north: z.number().min(-90).max(90),
      south: z.number().min(-90).max(90),
      east: z.number().min(-180).max(180),
      west: z.number().min(-180).max(180),
    }).optional(),
    limit: z.number().min(1).max(100).default(20),
    offset: z.number().min(0).default(0),
    sort: z.enum(['distance', 'rating', 'name', 'created_at']).default('rating'),
  }).strict(),
};

// User validation schemas
export const UserValidation = {
  registration: z.object({
    email: validateEmail,
    password: z.string()
      .min(8, 'Password must be at least 8 characters')
      .max(128, 'Password must be less than 128 characters')
      .regex(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]/, 
        'Password must contain uppercase, lowercase, number and special character'),
    
    name: z.string()
      .min(1, 'Name is required')
      .max(100, 'Name must be less than 100 characters')
      .transform(sanitizeString),
    
    terms_accepted: z.boolean().refine(val => val === true, 'Must accept terms'),
    privacy_accepted: z.boolean().refine(val => val === true, 'Must accept privacy policy'),
    
    // Optional profile fields
    phone: validatePhone.optional(),
    date_of_birth: z.string().date().optional(),
    preferences: z.object({
      notifications: z.boolean().default(true),
      marketing: z.boolean().default(false),
      location_sharing: z.boolean().default(false),
    }).optional(),
  }).strict(),

  profile_update: z.object({
    name: z.string().min(1).max(100).transform(sanitizeString).optional(),
    phone: validatePhone.optional(),
    bio: z.string().max(500).transform(sanitizeString).optional(),
    avatar_url: validateURL.optional(),
    preferences: z.object({
      notifications: z.boolean(),
      marketing: z.boolean(),
      location_sharing: z.boolean(),
    }).optional(),
  }).strict(),
};

// Review validation schemas
export const ReviewValidation = {
  create: z.object({
    business_id: validateUUID,
    rating: z.number().min(1).max(5),
    text: z.string()
      .min(10, 'Review must be at least 10 characters')
      .max(2000, 'Review must be less than 2000 characters')
      .transform(sanitizeString),
    
    // Photo attachments (optional)
    photos: z.array(z.object({
      url: validateURL,
      caption: z.string().max(200).transform(sanitizeString).optional(),
    })).max(10).optional(),
    
    // Visit verification
    visit_verification: z.object({
      visit_date: z.string().date(),
      receipt_number: z.string().optional(),
      verification_method: z.enum(['receipt', 'location', 'payment']),
    }).optional(),
  }).strict(),

  update: z.object({
    rating: z.number().min(1).max(5).optional(),
    text: z.string().min(10).max(2000).transform(sanitizeString).optional(),
  }).strict(),

  response: z.object({
    review_id: validateUUID,
    text: z.string()
      .min(10, 'Response must be at least 10 characters')
      .max(1000, 'Response must be less than 1000 characters')
      .transform(sanitizeString),
  }).strict(),
};

/**
 * High-performance validation middleware
 * Implements caching and rate limiting for security
 */
export class ValidationMiddleware {
  private static validationCache = new Map<string, any>();
  private static rateLimitMap = new Map<string, number[]>();

  /**
   * Validate data with caching and performance optimization
   */
  static async validate<T>(
    schema: z.ZodSchema<T>,
    data: unknown,
    context: {
      userId?: string;
      operation: string;
      rateLimit?: number;
    }
  ): Promise<{
    success: boolean;
    data?: T;
    errors?: z.ZodError;
    performance: {
      validationTime: number;
      cached: boolean;
    };
  }> {
    const startTime = performance.now();
    
    try {
      // Rate limiting check
      if (context.rateLimit && context.userId) {
        const isRateLimited = this.checkRateLimit(context.userId, context.operation, context.rateLimit);
        if (isRateLimited) {
          logger.security({
            action: 'rate_limit_exceeded',
            userId: context.userId,
            operation: context.operation,
            timestamp: Date.now(),
          });
          
          throw new Error('Rate limit exceeded');
        }
      }

      // Check validation cache
      const cacheKey = `${context.operation}_${JSON.stringify(data)}`;
      const cached = this.validationCache.get(cacheKey);
      
      if (cached) {
        return {
          success: true,
          data: cached,
          performance: {
            validationTime: performance.now() - startTime,
            cached: true,
          },
        };
      }

      // Perform validation
      const result = schema.parse(data);
      
      // Cache successful validation
      this.validationCache.set(cacheKey, result);
      
      // Clean cache periodically
      if (this.validationCache.size > 1000) {
        this.cleanValidationCache();
      }

      const validationTime = performance.now() - startTime;
      
      // Log validation performance
      logger.performance(`Validation for ${context.operation} completed in ${validationTime.toFixed(2)}ms`);
      
      // Log security event for sensitive operations
      if (['user_registration', 'business_creation', 'review_creation'].includes(context.operation)) {
        logger.security({
          action: 'data_validation',
          operation: context.operation,
          userId: context.userId,
          success: true,
          timestamp: Date.now(),
        });
      }

      return {
        success: true,
        data: result,
        performance: {
          validationTime,
          cached: false,
        },
      };

    } catch (error) {
      const validationTime = performance.now() - startTime;
      
      // Log validation failure for security monitoring
      logger.security({
        action: 'validation_failure',
        operation: context.operation,
        userId: context.userId,
        error: error instanceof z.ZodError ? error.issues : error.message,
        timestamp: Date.now(),
      });

      if (error instanceof z.ZodError) {
        return {
          success: false,
          errors: error,
          performance: {
            validationTime,
            cached: false,
          },
        };
      }

      throw error;
    }
  }

  /**
   * Rate limiting implementation
   */
  private static checkRateLimit(userId: string, operation: string, limit: number): boolean {
    const key = `${userId}_${operation}`;
    const now = Date.now();
    const window = 60000; // 1 minute window
    
    let requests = this.rateLimitMap.get(key) || [];
    
    // Remove old requests outside the window
    requests = requests.filter(timestamp => now - timestamp < window);
    
    // Check if limit exceeded
    if (requests.length >= limit) {
      return true;
    }
    
    // Add current request
    requests.push(now);
    this.rateLimitMap.set(key, requests);
    
    return false;
  }

  /**
   * Clean validation cache to prevent memory leaks
   */
  private static cleanValidationCache(): void {
    // Remove oldest 50% of cache entries
    const entries = Array.from(this.validationCache.entries());
    const toRemove = entries.slice(0, Math.floor(entries.length / 2));
    
    toRemove.forEach(([key]) => {
      this.validationCache.delete(key);
    });
    
    logger.debug('Validation cache cleaned');
  }

  /**
   * Sanitize HTML content to prevent XSS
   */
  static sanitizeHTML(html: string): string {
    // Basic HTML sanitization - in production, use a library like DOMPurify
    return html
      .replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '')
      .replace(/<iframe\b[^<]*(?:(?!<\/iframe>)<[^<]*)*<\/iframe>/gi, '')
      .replace(/javascript:/gi, '')
      .replace(/on\w+\s*=/gi, '');
  }

  /**
   * Validate file uploads
   */
  static validateFileUpload(file: {
    name: string;
    size: number;
    type: string;
  }, constraints: {
    maxSize: number;
    allowedTypes: string[];
    allowedExtensions: string[];
  }): { valid: boolean; error?: string } {
    // Check file size
    if (file.size > constraints.maxSize) {
      return {
        valid: false,
        error: `File size ${file.size} exceeds maximum ${constraints.maxSize} bytes`,
      };
    }

    // Check MIME type
    if (!constraints.allowedTypes.includes(file.type)) {
      return {
        valid: false,
        error: `File type ${file.type} not allowed`,
      };
    }

    // Check file extension
    const extension = file.name.split('.').pop()?.toLowerCase();
    if (!extension || !constraints.allowedExtensions.includes(extension)) {
      return {
        valid: false,
        error: `File extension ${extension} not allowed`,
      };
    }

    return { valid: true };
  }
}

// Export validation schemas and middleware
export const validate = ValidationMiddleware.validate;
export const sanitizeHTML = ValidationMiddleware.sanitizeHTML;
export const validateFileUpload = ValidationMiddleware.validateFileUpload;
```

## ðŸ” Client-Side Encryption ([lib/supabase/security/encryption.ts](mdc:lib/supabase/security/encryption.ts))

```typescript
// REQUIRED: Client-side encryption for sensitive data
import CryptoJS from 'crypto-js';
import { logger } from '@lib/utils/logger';

/**
 * High-performance client-side encryption
 * Implements AES-256 encryption with key rotation support
 */
export class EncryptionManager {
  private static readonly ALGORITHM = 'AES';
  private static readonly KEY_SIZE = 256;
  private static readonly IV_SIZE = 16;
  
  // Key rotation every 24 hours
  private static readonly KEY_ROTATION_INTERVAL = 24 * 60 * 60 * 1000;
  private static encryptionKey: string | null = null;
  private static keyTimestamp: number = 0;

  /**
   * Generate or rotate encryption key
   */
  private static getEncryptionKey(): string {
    const now = Date.now();
    
    // Rotate key if expired or doesn't exist
    if (!this.encryptionKey || (now - this.keyTimestamp) > this.KEY_ROTATION_INTERVAL) {
      this.encryptionKey = CryptoJS.lib.WordArray.random(this.KEY_SIZE / 8).toString();
      this.keyTimestamp = now;
      
      logger.security({
        action: 'encryption_key_rotation',
        timestamp: now,
      });
    }
    
    return this.encryptionKey;
  }

  /**
   * Encrypt sensitive data before storing in Supabase
   */
  static encrypt(data: string, additionalKey?: string): {
    encrypted: string;
    iv: string;
    keyId: string;
  } {
    try {
      const key = additionalKey || this.getEncryptionKey();
      const iv = CryptoJS.lib.WordArray.random(this.IV_SIZE);
      
      const encrypted = CryptoJS.AES.encrypt(data, key, {
        iv: iv,
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7,
      });

      return {
        encrypted: encrypted.toString(),
        iv: iv.toString(),
        keyId: this.keyTimestamp.toString(), // For key rotation tracking
      };

    } catch (error) {
      logger.error('Encryption failed:', error);
      throw new Error('Encryption failed');
    }
  }

  /**
   * Decrypt sensitive data retrieved from Supabase
   */
  static decrypt(encryptedData: {
    encrypted: string;
    iv: string;
    keyId?: string;
  }, additionalKey?: string): string {
    try {
      const key = additionalKey || this.getEncryptionKey();
      
      const decrypted = CryptoJS.AES.decrypt(encryptedData.encrypted, key, {
        iv: CryptoJS.enc.Hex.parse(encryptedData.iv),
        mode: CryptoJS.mode.CBC,
        padding: CryptoJS.pad.Pkcs7,
      });

      return decrypted.toString(CryptoJS.enc.Utf8);

    } catch (error) {
      logger.error('Decryption failed:', error);
      throw new Error('Decryption failed');
    }
  }

  /**
   * Hash sensitive data for secure comparison
   */
  static hash(data: string, salt?: string): {
    hash: string;
    salt: string;
  } {
    const actualSalt = salt || CryptoJS.lib.WordArray.random(32).toString();
    const hash = CryptoJS.PBKDF2(data, actualSalt, {
      keySize: 32,
      iterations: 10000,
    }).toString();

    return { hash, salt: actualSalt };
  }

  /**
   * Verify hashed data
   */
  static verifyHash(data: string, hash: string, salt: string): boolean {
    const computed = this.hash(data, salt);
    return computed.hash === hash;
  }

  /**
   * Generate secure random tokens
   */
  static generateToken(length: number = 32): string {
    return CryptoJS.lib.WordArray.random(length).toString();
  }

  /**
   * Encrypt user PII before database storage
   */
  static encryptPII(data: {
    email?: string;
    phone?: string;
    address?: string;
    ssn?: string;
  }): Record<string, any> {
    const encrypted: Record<string, any> = {};

    Object.entries(data).forEach(([key, value]) => {
      if (value) {
        encrypted[key] = this.encrypt(value);
      }
    });

    return encrypted;
  }

  /**
   * Decrypt user PII retrieved from database
   */
  static decryptPII(encryptedData: Record<string, any>): Record<string, string> {
    const decrypted: Record<string, string> = {};

    Object.entries(encryptedData).forEach(([key, value]) => {
      if (value && typeof value === 'object' && value.encrypted) {
        try {
          decrypted[key] = this.decrypt(value);
        } catch (error) {
          logger.error(`Failed to decrypt PII field ${key}:`, error);
          decrypted[key] = '[DECRYPTION_FAILED]';
        }
      }
    });

    return decrypted;
  }
}

// Export encryption utilities
export const encrypt = EncryptionManager.encrypt;
export const decrypt = EncryptionManager.decrypt;
export const hash = EncryptionManager.hash;
export const verifyHash = EncryptionManager.verifyHash;
export const generateToken = EncryptionManager.generateToken;
export const encryptPII = EncryptionManager.encryptPII;
export const decryptPII = EncryptionManager.decryptPII;
```

## ðŸš¨ Security Policy Enforcement

### Required Security Headers
```typescript
// REQUIRED: Implement comprehensive security headers
export const SECURITY_HEADERS = {
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains; preload',
  'Content-Security-Policy': `
    default-src 'self';
    script-src 'self' 'unsafe-inline' 'unsafe-eval' *.supabase.co;
    style-src 'self' 'unsafe-inline' fonts.googleapis.com;
    img-src 'self' data: https: *.supabase.co;
    font-src 'self' fonts.gstatic.com;
    connect-src 'self' *.supabase.co wss://*.supabase.co;
    media-src 'self' *.supabase.co;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
    frame-ancestors 'none';
  `.replace(/\s+/g, ' ').trim(),
  'X-Frame-Options': 'DENY',
  'X-Content-Type-Options': 'nosniff',
  'Referrer-Policy': 'strict-origin-when-cross-origin',
  'Permissions-Policy': 'camera=(), microphone=(), geolocation=()',
};
```

### Database Security Functions
```sql
-- REQUIRED: Implement security functions in Supabase
-- lib/supabase/migrations/security_functions.sql

-- Audit logging function
CREATE OR REPLACE FUNCTION audit_log_trigger()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_log (
    table_name,
    operation,
    old_data,
    new_data,
    user_id,
    timestamp
  ) VALUES (
    TG_TABLE_NAME,
    TG_OP,
    CASE WHEN TG_OP = 'DELETE' THEN row_to_json(OLD) ELSE NULL END,
    CASE WHEN TG_OP IN ('INSERT', 'UPDATE') THEN row_to_json(NEW) ELSE NULL END,
    auth.uid(),
    NOW()
  );
  
  RETURN CASE WHEN TG_OP = 'DELETE' THEN OLD ELSE NEW END;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Rate limiting function
CREATE OR REPLACE FUNCTION check_rate_limit(
  user_id UUID,
  action_type TEXT,
  max_requests INTEGER,
  time_window INTERVAL
)
RETURNS BOOLEAN AS $$
DECLARE
  request_count INTEGER;
BEGIN
  SELECT COUNT(*)
  INTO request_count
  FROM rate_limit_log
  WHERE user_id = $1
    AND action_type = $2
    AND created_at > NOW() - time_window;
  
  IF request_count >= max_requests THEN
    RETURN FALSE;
  END IF;
  
  INSERT INTO rate_limit_log (user_id, action_type, created_at)
  VALUES (user_id, action_type, NOW());
  
  RETURN TRUE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Data anonymization function
CREATE OR REPLACE FUNCTION anonymize_user_data(user_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE users SET
    email = 'anonymized_' || user_id || '@example.com',
    name = 'Anonymized User',
    phone = NULL,
    address = NULL
  WHERE id = user_id;
  
  UPDATE reviews SET
    text = '[Review anonymized]'
  WHERE user_id = user_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## ðŸš¨ Critical Security Requirements

### Always Implement:
1. **Input Validation**: Validate all user inputs with Zod schemas
2. **Data Encryption**: Encrypt all PII before database storage
3. **Rate Limiting**: Implement rate limiting for all sensitive operations
4. **Audit Logging**: Log all data access and modifications
5. **RLS Policies**: Use Row Level Security for all tables
6. **Security Headers**: Implement comprehensive security headers
7. **Error Handling**: Never expose internal errors to clients

### Never Do:
- Store unencrypted sensitive data
- Skip input validation
- Ignore rate limiting
- Expose internal database errors
- Allow SQL injection vulnerabilities
- Skip audit logging for sensitive operations
- Use weak encryption algorithms

### Security Targets:
- **Zero** data breaches
- **<1%** false positive rate for security checks
- **100%** audit coverage for sensitive operations
- **<100ms** security validation latency
- **OWASP Top 10** compliance

**Remember: Security is not a feature - it's a fundamental requirement.**

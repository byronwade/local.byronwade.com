---
globs: "lib/supabase/realtime/**/*,**/realtime.ts,**/subscriptions.ts"
description: Supabase real-time subscriptions with performance optimization
---

# Supabase Real-Time & Live Data Management

## ðŸ”„ PERFORMANCE-OPTIMIZED REAL-TIME SUBSCRIPTIONS

**ALL REAL-TIME FEATURES MUST BE BANDWIDTH-EFFICIENT AND MEMORY-OPTIMIZED**

### Real-Time Subscription Manager ([lib/supabase/realtime/subscriptions.ts](mdc:lib/supabase/realtime/subscriptions.ts))

```typescript
// REQUIRED: High-performance real-time subscription management
import { RealtimeChannel, RealtimeChannelSendResponse } from '@supabase/supabase-js';
import { supabase, getPooledClient } from '../client';
import { logger } from '@lib/utils/logger';
import { CacheManager } from '@lib/utils/cacheManager';

/**
 * Optimized real-time subscription manager
 * Implements connection pooling, automatic reconnection, and bandwidth optimization
 */
export class RealtimeSubscriptionManager {
  private static instance: RealtimeSubscriptionManager;
  private channels: Map<string, RealtimeChannel> = new Map();
  private subscriptions: Map<string, Set<string>> = new Map();
  private connectionHealth: Map<string, number> = new Map();
  private readonly maxRetries = 3;
  private readonly retryDelay = 1000;

  /**
   * Singleton pattern for centralized subscription management
   */
  static getInstance(): RealtimeSubscriptionManager {
    if (!this.instance) {
      this.instance = new RealtimeSubscriptionManager();
    }
    return this.instance;
  }

  /**
   * Subscribe to real-time changes with intelligent batching
   * Optimizes for minimal bandwidth usage and connection reuse
   */
  async subscribe<T = any>(
    channelName: string,
    config: {
      table: string;
      event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';
      filter?: string;
      schema?: string;
    },
    callback: (payload: T) => void,
    options: {
      throttleMs?: number;
      batchUpdates?: boolean;
      priority?: 'high' | 'normal' | 'low';
    } = {}
  ): Promise<string> {
    const startTime = performance.now();
    const subscriptionId = this.generateSubscriptionId(channelName, config);

    try {
      // Check if channel already exists and reuse it
      let channel = this.channels.get(channelName);
      
      if (!channel) {
        // Create new channel with performance optimizations
        channel = supabase.channel(channelName, {
          config: {
            // Optimize for performance
            presence: { key: '' }, // Disable presence if not needed
            broadcast: { self: false }, // Reduce bandwidth
          },
        });

        // Setup connection monitoring
        this.setupChannelMonitoring(channel, channelName);
        
        this.channels.set(channelName, channel);
      }

      // Add subscription to the channel
      const { event = '*', filter, table, schema = 'public' } = config;
      
      // Apply throttling if specified
      const optimizedCallback = options.throttleMs 
        ? this.throttleCallback(callback, options.throttleMs)
        : callback;

      // Apply batching if specified
      const finalCallback = options.batchUpdates
        ? this.batchCallback(optimizedCallback, subscriptionId)
        : optimizedCallback;

      // Setup postgres changes listener with error handling
      channel.on(
        'postgres_changes',
        {
          event,
          schema,
          table,
          filter,
        },
        (payload) => {
          try {
            // Performance tracking
            logger.performance(`Real-time event received for ${table}: ${event}`);
            
            // Update cache invalidation
            this.handleCacheInvalidation(table, payload);
            
            // Execute callback
            finalCallback(payload);
            
          } catch (error) {
            logger.error(`Real-time callback error for ${subscriptionId}:`, error);
          }
        }
      );

      // Track subscription
      if (!this.subscriptions.has(channelName)) {
        this.subscriptions.set(channelName, new Set());
      }
      this.subscriptions.get(channelName)!.add(subscriptionId);

      // Subscribe to the channel if not already subscribed
      if (channel.state === 'closed') {
        const subscribeResponse = await channel.subscribe();
        
        if (subscribeResponse !== 'SUBSCRIBED') {
          throw new Error(`Failed to subscribe to channel: ${channelName}`);
        }
      }

      const duration = performance.now() - startTime;
      logger.performance(`Real-time subscription created in ${duration.toFixed(2)}ms`);
      
      logger.debug(`Real-time subscription active: ${subscriptionId} on ${channelName}`);
      
      return subscriptionId;

    } catch (error) {
      logger.error(`Failed to create real-time subscription:`, error);
      throw error;
    }
  }

  /**
   * Unsubscribe from real-time updates with cleanup
   */
  async unsubscribe(subscriptionId: string): Promise<void> {
    try {
      const channelName = this.getChannelNameFromSubscriptionId(subscriptionId);
      
      if (!channelName) {
        logger.warn(`Subscription not found: ${subscriptionId}`);
        return;
      }

      const subscriptions = this.subscriptions.get(channelName);
      if (subscriptions) {
        subscriptions.delete(subscriptionId);
        
        // If no more subscriptions, cleanup the channel
        if (subscriptions.size === 0) {
          const channel = this.channels.get(channelName);
          if (channel) {
            await channel.unsubscribe();
            this.channels.delete(channelName);
            this.subscriptions.delete(channelName);
            this.connectionHealth.delete(channelName);
            
            logger.debug(`Channel cleaned up: ${channelName}`);
          }
        }
      }

      logger.debug(`Real-time subscription removed: ${subscriptionId}`);

    } catch (error) {
      logger.error(`Failed to unsubscribe:`, error);
    }
  }

  /**
   * Broadcast messages to channel subscribers
   * Optimized for minimal latency and bandwidth usage
   */
  async broadcast(
    channelName: string,
    eventName: string,
    payload: any,
    options: {
      priority?: 'high' | 'normal' | 'low';
      compression?: boolean;
    } = {}
  ): Promise<RealtimeChannelSendResponse> {
    const startTime = performance.now();

    try {
      const channel = this.channels.get(channelName);
      
      if (!channel) {
        throw new Error(`Channel not found: ${channelName}`);
      }

      // Apply compression for large payloads
      const optimizedPayload = options.compression 
        ? this.compressPayload(payload)
        : payload;

      const response = await channel.send({
        type: 'broadcast',
        event: eventName,
        payload: optimizedPayload,
      });

      const duration = performance.now() - startTime;
      logger.performance(`Broadcast sent in ${duration.toFixed(2)}ms`);

      return response;

    } catch (error) {
      logger.error(`Broadcast failed:`, error);
      throw error;
    }
  }

  /**
   * Setup connection health monitoring
   */
  private setupChannelMonitoring(channel: RealtimeChannel, channelName: string): void {
    let reconnectAttempts = 0;
    
    // Monitor connection state
    channel.onError((error) => {
      logger.error(`Real-time channel error on ${channelName}:`, error);
      this.connectionHealth.set(channelName, Date.now());
    });

    channel.onClose(() => {
      logger.warn(`Real-time channel closed: ${channelName}`);
      
      // Attempt reconnection with exponential backoff
      if (reconnectAttempts < this.maxRetries) {
        const delay = this.retryDelay * Math.pow(2, reconnectAttempts);
        
        setTimeout(async () => {
          try {
            await channel.subscribe();
            reconnectAttempts = 0;
            logger.info(`Real-time channel reconnected: ${channelName}`);
          } catch (error) {
            reconnectAttempts++;
            logger.error(`Reconnection failed for ${channelName}:`, error);
          }
        }, delay);
      }
    });
  }

  /**
   * Intelligent cache invalidation based on real-time updates
   */
  private handleCacheInvalidation(table: string, payload: any): void {
    const { eventType, new: newRecord, old: oldRecord } = payload;
    
    // Invalidate relevant cache keys
    const cacheKeys = this.generateCacheKeys(table, newRecord, oldRecord);
    
    cacheKeys.forEach(key => {
      CacheManager.memory.delete(key);
      logger.debug(`Cache invalidated: ${key}`);
    });
  }

  /**
   * Generate cache keys that need invalidation
   */
  private generateCacheKeys(table: string, newRecord: any, oldRecord: any): string[] {
    const keys: string[] = [];
    
    // Table-specific invalidation patterns
    switch (table) {
      case 'businesses':
        if (newRecord?.id) {
          keys.push(`business_${newRecord.id}_*`);
          keys.push(`business_search_*`);
          keys.push(`nearby_*`);
        }
        break;
        
      case 'reviews':
        if (newRecord?.business_id) {
          keys.push(`business_${newRecord.business_id}_*`);
        }
        break;
        
      default:
        keys.push(`${table}_*`);
    }
    
    return keys;
  }

  /**
   * Throttle callback execution to prevent overwhelming the UI
   */
  private throttleCallback<T>(callback: (payload: T) => void, delayMs: number) {
    let lastCall = 0;
    let timeoutId: NodeJS.Timeout;
    
    return (payload: T) => {
      const now = Date.now();
      
      if (now - lastCall >= delayMs) {
        lastCall = now;
        callback(payload);
      } else {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          lastCall = Date.now();
          callback(payload);
        }, delayMs - (now - lastCall));
      }
    };
  }

  /**
   * Batch multiple rapid updates into single callback execution
   */
  private batchCallback<T>(callback: (payload: T) => void, subscriptionId: string) {
    const batchQueue: T[] = [];
    let batchTimeout: NodeJS.Timeout;
    const batchDelay = 100; // 100ms batching window
    
    return (payload: T) => {
      batchQueue.push(payload);
      
      clearTimeout(batchTimeout);
      batchTimeout = setTimeout(() => {
        if (batchQueue.length > 0) {
          // Process batch - for now, just use the latest payload
          const latestPayload = batchQueue[batchQueue.length - 1];
          callback(latestPayload);
          batchQueue.length = 0;
        }
      }, batchDelay);
    };
  }

  /**
   * Compress payload for bandwidth optimization
   */
  private compressPayload(payload: any): any {
    // Simple compression strategy - remove unnecessary fields
    if (typeof payload === 'object' && payload !== null) {
      const compressed = { ...payload };
      
      // Remove metadata fields that aren't needed for UI updates
      delete compressed.created_at;
      delete compressed.updated_at;
      delete compressed.metadata;
      
      return compressed;
    }
    
    return payload;
  }

  /**
   * Generate unique subscription ID
   */
  private generateSubscriptionId(channelName: string, config: any): string {
    const configHash = btoa(JSON.stringify(config)).slice(0, 8);
    return `${channelName}_${configHash}_${Date.now()}`;
  }

  /**
   * Extract channel name from subscription ID
   */
  private getChannelNameFromSubscriptionId(subscriptionId: string): string | null {
    // Find the channel that contains this subscription
    for (const [channelName, subscriptions] of this.subscriptions) {
      if (subscriptions.has(subscriptionId)) {
        return channelName;
      }
    }
    return null;
  }

  /**
   * Get connection health status
   */
  getConnectionHealth(): Record<string, {
    status: 'healthy' | 'degraded' | 'offline';
    lastError?: number;
    subscriptionCount: number;
  }> {
    const health: Record<string, any> = {};
    
    for (const [channelName, channel] of this.channels) {
      const lastError = this.connectionHealth.get(channelName);
      const subscriptionCount = this.subscriptions.get(channelName)?.size || 0;
      
      let status: 'healthy' | 'degraded' | 'offline';
      
      if (channel.state === 'joined') {
        status = lastError && (Date.now() - lastError < 60000) ? 'degraded' : 'healthy';
      } else {
        status = 'offline';
      }
      
      health[channelName] = {
        status,
        lastError,
        subscriptionCount,
      };
    }
    
    return health;
  }

  /**
   * Cleanup all subscriptions (for app shutdown)
   */
  async cleanup(): Promise<void> {
    logger.info('Cleaning up real-time subscriptions...');
    
    for (const [channelName, channel] of this.channels) {
      try {
        await channel.unsubscribe();
        logger.debug(`Channel unsubscribed: ${channelName}`);
      } catch (error) {
        logger.error(`Error unsubscribing channel ${channelName}:`, error);
      }
    }
    
    this.channels.clear();
    this.subscriptions.clear();
    this.connectionHealth.clear();
    
    logger.info('Real-time cleanup completed');
  }
}

// Export singleton instance
export const realtimeManager = RealtimeSubscriptionManager.getInstance();

// React hook for easy real-time subscriptions
export function useRealtimeSubscription<T = any>(
  channelName: string,
  config: {
    table: string;
    event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';
    filter?: string;
  },
  callback: (payload: T) => void,
  dependencies: any[] = []
) {
  const [subscriptionId, setSubscriptionId] = useState<string | null>(null);
  const [connectionStatus, setConnectionStatus] = useState<'connecting' | 'connected' | 'error'>('connecting');
  
  useEffect(() => {
    let mounted = true;
    
    const subscribe = async () => {
      try {
        const id = await realtimeManager.subscribe(
          channelName,
          config,
          callback,
          { throttleMs: 100 } // Default throttling
        );
        
        if (mounted) {
          setSubscriptionId(id);
          setConnectionStatus('connected');
        }
      } catch (error) {
        logger.error('Real-time subscription error:', error);
        if (mounted) {
          setConnectionStatus('error');
        }
      }
    };
    
    subscribe();
    
    return () => {
      mounted = false;
      if (subscriptionId) {
        realtimeManager.unsubscribe(subscriptionId);
      }
    };
  }, [channelName, JSON.stringify(config), ...dependencies]);
  
  return { connectionStatus, subscriptionId };
}
```

## ðŸ“Š Real-Time Performance Monitoring

### Connection Health Dashboard
```typescript
// REQUIRED: Monitor real-time connection performance
export class RealtimePerformanceMonitor {
  private static metrics = {
    messagesSent: 0,
    messagesReceived: 0,
    connectionErrors: 0,
    averageLatency: 0,
    bandwidthUsage: 0,
  };

  static trackMessage(type: 'sent' | 'received', size: number, latency?: number): void {
    if (type === 'sent') {
      this.metrics.messagesSent++;
    } else {
      this.metrics.messagesReceived++;
      if (latency) {
        this.metrics.averageLatency = 
          (this.metrics.averageLatency + latency) / 2;
      }
    }
    
    this.metrics.bandwidthUsage += size;
    
    // Alert on high latency
    if (latency && latency > 1000) {
      logger.warn(`High real-time latency detected: ${latency}ms`);
    }
  }

  static trackError(): void {
    this.metrics.connectionErrors++;
    
    // Alert on error rate
    const errorRate = this.metrics.connectionErrors / 
      (this.metrics.messagesSent + this.metrics.messagesReceived);
    
    if (errorRate > 0.05) { // 5% error rate
      logger.critical(`High real-time error rate: ${(errorRate * 100).toFixed(2)}%`);
    }
  }

  static getMetrics() {
    return { ...this.metrics };
  }
}
```

## ðŸš¨ Critical Real-Time Requirements

### Always Implement:
1. **Connection Pooling**: Reuse channels for multiple subscriptions
2. **Error Handling**: Implement automatic reconnection with exponential backoff
3. **Throttling**: Prevent UI overwhelming with rapid updates
4. **Cache Invalidation**: Update caches based on real-time events
5. **Bandwidth Optimization**: Compress payloads and batch updates
6. **Performance Monitoring**: Track latency and error rates

### Never Do:
- Create new channels for each subscription
- Ignore connection errors
- Allow unlimited real-time updates
- Skip cache invalidation on updates
- Send uncompressed large payloads
- Miss cleanup on component unmount

### Performance Targets:
- **Connection Latency**: <100ms average
- **Message Throughput**: >1000 messages/second
- **Error Rate**: <1% of all messages
- **Bandwidth Usage**: <10KB/minute per subscription

**Remember: Real-time features should enhance, not degrade, user experience.**

---
alwaysApply: false
description: Enterprise-grade feature flags for Web (SSR-first) using Vercel Flags, Edge Config, Toolbar, with caching, performance, and SEO-safe patterns
globs: *.js,*.jsx,*.ts,*.tsx,src/app/**,src/components/**,src/lib/**
---
# Enterprise Feature Flags (Web) â€” Vercel Flags + Edge Config

Purpose: Standardize feature flag implementation across the entire web app with performance-first, SSR-first behavior, minimal API requests, and SEO-safe rendering.

## Golden Rules
- Prefer SSR: Resolve flags in Server Components, Route Handlers, Server Actions, and Middleware.
- One decision per request: Evaluate all flags once at the top-level (e.g., `src/app/(site)/layout.js`) and pass to children.
- Cache decisions: Use React `cache` to memoize per-input decisions; avoid unstable cache APIs.
- Minimal requests: Use Vercel Edge Config for reads; no DB hits on hot paths.
- SEO-safe: Default to the canonical, indexable experience; never gate critical metadata purely client-side.
- No feature removals: Add flags progressively; do not remove existing features.
- Bun-first dev workflow: Use `bun` for installing dependencies and scripts.

## Installation
```bash
bun add @vercel/flags @vercel/edge-config @vercel/toolbar
```

## Directory Conventions
- Flag declarations: `src/lib/flags/definitions.ts` (or `.js`)
- Server helpers: `src/lib/flags/server.ts`
- Client bridge (optional): `src/lib/flags/client.ts`
- Toolbar API: `src/app/api/flags/route.ts`
- Edge Config keys: `feature:<flag-key>`

## Definitions (SSR)
```ts
// src/lib/flags/definitions.ts
import { flag } from '@vercel/flags/next';
import { get } from '@vercel/edge-config';

export const newNavigationFlag = flag<boolean>({
  key: 'new-navigation',
  decide: async () => {
    // 1) Fast path: Edge Config
    const ec = await get<boolean>('feature:new-navigation');
    if (typeof ec === 'boolean') return ec;

    // 2) Environment fallback
    const env = process.env.NEXT_PUBLIC_FLAG_NEW_NAV;
    if (env === 'true') return true;
    if (env === 'false') return false;

    // 3) Safe default
    return false;
  }
});

export const flags = {
  newNavigation: newNavigationFlag
};
```

## Server Helper (Cached Decisions)
```ts
// src/lib/flags/server.ts
import { cache } from 'react';
import { flags } from './definitions';

type FlagKey = keyof typeof flags;

export const isEnabled = cache(async (key: FlagKey) => {
  return flags[key]();
});

export const evaluateAllFlags = cache(async () => {
  const entries = await Promise.all(
    (Object.keys(flags) as FlagKey[]).map(async (k) => [k, await flags[k]()] as const)
  );
  return Object.fromEntries(entries) as Record<FlagKey, boolean>;
});
```

## SSR Usage (One Pass at Layout)
```tsx
// src/app/(site)/layout.js
import { evaluateAllFlags } from '@/src/lib/flags/server';

export default async function RootLayout({ children }) {
  const ff = await evaluateAllFlags();

  return (
    <html lang="en">
      <body data-flag-new-navigation={ff.newNavigation ? '1' : '0'}>
        {children}
      </body>
    </html>
  );
}
```

- Pass flags via props/context or data attributes. Avoid re-evaluating in children.

## Route Handlers / Server Actions
```ts
// Example: src/app/api/example/route.ts
import { isEnabled } from '@/src/lib/flags/server';

export async function GET() {
  const on = await isEnabled('newNavigation');
  // Branch server logic safely without extra requests
  return new Response(JSON.stringify({ on }), { headers: { 'content-type': 'application/json' } });
}
```

## Client Bridge (Optional)
```ts
// src/lib/flags/client.ts
export function readFlagFromDOM(attr: string): boolean {
  if (typeof document === 'undefined') return false;
  return document.body.getAttribute(attr) === '1';
}
```

## Toolbar Integration
- Expose a minimal API that returns the current flag map.
```ts
// src/app/api/flags/route.ts
import { evaluateAllFlags } from '@/src/lib/flags/server';

export async function GET() {
  const flags = await evaluateAllFlags();
  return new Response(JSON.stringify(flags), {
    headers: { 'content-type': 'application/json', 'cache-control': 'no-store' }
  });
}
```
- Enable Vercel Toolbar in environments where QA needs flag overrides.

## Edge Config Guidance
- Key format: `feature:<flag-key>`.
- Reads are global, fast, and cost 0 DB queries.
- Update via Vercel dashboard or management API for instant rollouts.

## Performance & Caching
- Resolve all flags once per request in the root layout.
- Memoize decision functions with `cache`.
- Never fetch flags client-side on critical paths.
- Log decision latencies to existing logger utilities when available.

## SEO & Accessibility
- Pre-render canonical content as the default; flags may progressively enhance.
- Avoid gating titling/canonical tags on client-only flags.
- Ensure focus order and semantics remain valid in both flag states.

## Observability
- Tag web analytics and logs with flag states (no PII).
- Example log shape: `{ feature: 'new-navigation', enabled: true, route: '/path' }`.

## Testing
- Unit test decide functions with Edge Config mocks.
- E2E: Verify both states are accessible, performant, and SEO-safe.

## Rollout Strategy
- Start disabled; enable for internal users, then % rollouts via Edge Config keys like `feature:new-navigation:percent` if needed.
- Always keep rollback path: a single Edge Config flip must disable immediately.

## Checklist
- Bun deps installed
- Flags declared in `src/lib/flags/definitions.ts`
- Cached helpers in `src/lib/flags/server.ts`
- Evaluated once in `src/app/(site)/layout.js`
- Toolbar API at `src/app/api/flags/route.ts`
- Edge Config keys created
- Logs/analytics tagged

[Top-level layout](mdc:src/app/(site)/layout.js)
---
alwaysApply: true
description: Supabase architecture and integration patterns with performance-first design
---

# Supabase Architecture & Performance-First Integration

## 🚀 PERFORMANCE-FIRST SUPABASE INTEGRATION

**ALL SUPABASE INTEGRATIONS MUST PRIORITIZE SPEED, SECURITY, AND MINIMAL API REQUESTS**

### Core Architecture Principles

1. **Connection Pooling**: Always use connection pooling for optimal performance
2. **Query Optimization**: Minimize database round trips with efficient queries
3. **Caching Strategy**: Implement intelligent caching to reduce API calls
4. **Security First**: RLS policies, proper authentication, and data validation
5. **Type Safety**: Full TypeScript integration with generated types

## 📁 Project Structure (Organized & Scalable)

```
lib/
├── supabase/
│   ├── client.ts              # Main Supabase client with connection pooling
│   ├── middleware.ts          # Auth middleware and session handling
│   ├── types.ts              # Generated TypeScript types
│   ├── queries/              # Optimized query functions
│   │   ├── business.ts       # Business-related queries
│   │   ├── user.ts           # User management queries
│   │   ├── auth.ts           # Authentication queries
│   │   └── analytics.ts      # Analytics and metrics queries
│   ├── mutations/            # Database write operations
│   │   ├── business.ts       # Business CRUD operations
│   │   ├── user.ts           # User management operations
│   │   └── review.ts         # Review management operations
│   ├── cache/                # Intelligent caching layer
│   │   ├── strategy.ts       # Cache strategy implementation
│   │   ├── invalidation.ts   # Cache invalidation logic
│   │   └── keys.ts           # Cache key management
│   ├── realtime/             # Real-time subscriptions
│   │   ├── subscriptions.ts  # Subscription management
│   │   └── channels.ts       # Channel configuration
│   ├── storage/              # File storage operations
│   │   ├── upload.ts         # Optimized file uploads
│   │   └── cdn.ts            # CDN integration
│   ├── security/             # Security utilities
│   │   ├── rls.ts            # Row Level Security helpers
│   │   ├── validation.ts     # Data validation schemas
│   │   └── encryption.ts     # Client-side encryption
│   └── migrations/           # Database migrations
│       ├── initial.sql       # Initial schema
│       └── updates/          # Incremental updates
```

## 🔧 High-Performance Client Configuration

### Primary Client ([lib/supabase/client.ts](mdc:lib/supabase/client.ts))
```typescript
// REQUIRED: High-performance Supabase client with connection pooling
import { createClient, SupabaseClient } from '@supabase/supabase-js';
import { Database } from './types';
import { logger } from '@lib/utils/logger';
import { CacheManager } from '@lib/utils/cacheManager';

// Performance-optimized configuration
const supabaseConfig = {
  auth: {
    // Reduce auth overhead with persistent sessions
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true,
    // Optimize storage for performance
    storage: typeof window !== 'undefined' ? window.localStorage : undefined,
  },
  db: {
    // Connection pooling configuration
    schema: 'public',
    // Optimize for read performance
    enableReadReplicas: true,
  },
  realtime: {
    // Efficient heartbeat for connection management
    heartbeatIntervalMs: 30000,
    // Optimize for minimal bandwidth usage
    enableCompression: true,
  },
  global: {
    // Performance headers
    headers: {
      'apikey': process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      'Authorization': `Bearer ${process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!}`,
      // Performance optimizations
      'Cache-Control': 'public, max-age=300, stale-while-revalidate=600',
      'Connection': 'keep-alive',
    },
  },
};

// Singleton pattern for optimal connection management
class SupabaseManager {
  private static instance: SupabaseClient<Database>;
  private static connectionPool: Map<string, SupabaseClient> = new Map();

  /**
   * Get the main Supabase client instance
   * Uses singleton pattern to prevent multiple connections
   */
  public static getClient(): SupabaseClient<Database> {
    if (!this.instance) {
      const startTime = performance.now();
      
      this.instance = createClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        supabaseConfig
      );

      const initTime = performance.now() - startTime;
      logger.performance(`Supabase client initialized in ${initTime.toFixed(2)}ms`);

      // Monitor connection health
      this.setupConnectionMonitoring();
    }

    return this.instance;
  }

  /**
   * Get specialized client for specific operations
   * Enables connection pooling for high-traffic scenarios
   */
  public static getPooledClient(poolKey: string): SupabaseClient<Database> {
    if (!this.connectionPool.has(poolKey)) {
      const client = createClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          ...supabaseConfig,
          // Pool-specific optimizations
          db: {
            ...supabaseConfig.db,
            schema: poolKey === 'analytics' ? 'analytics' : 'public',
          },
        }
      );

      this.connectionPool.set(poolKey, client);
      logger.debug(`Created pooled connection for: ${poolKey}`);
    }

    return this.connectionPool.get(poolKey)!;
  }

  /**
   * Monitor connection health and performance
   */
  private static setupConnectionMonitoring(): void {
    // Performance monitoring for database operations
    const originalFrom = this.instance.from;
    this.instance.from = function(table: string) {
      const startTime = performance.now();
      const query = originalFrom.call(this, table);
      
      // Wrap execute methods with performance tracking
      const originalExecute = query.then;
      query.then = function(callback) {
        return originalExecute.call(this, (result) => {
          const duration = performance.now() - startTime;
          logger.performance(`Supabase query "${table}" executed in ${duration.toFixed(2)}ms`);
          
          // Alert on slow queries
          if (duration > 1000) {
            logger.warn(`Slow Supabase query detected: ${table} took ${duration.toFixed(2)}ms`);
          }
          
          return callback ? callback(result) : result;
        });
      };
      
      return query;
    };
  }

  /**
   * Graceful cleanup for connection pooling
   */
  public static cleanup(): void {
    this.connectionPool.clear();
    logger.debug('Supabase connection pool cleaned up');
  }
}

// Export the optimized client
export const supabase = SupabaseManager.getClient();
export const getPooledClient = SupabaseManager.getPooledClient;
export const cleanupConnections = SupabaseManager.cleanup;

// Type exports for better developer experience
export type { Database } from './types';
export type Tables<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Row'];
export type Inserts<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Insert'];
export type Updates<T extends keyof Database['public']['Tables']> = 
  Database['public']['Tables'][T]['Update'];
```

## 🔐 Security-First Authentication

### Auth Middleware ([lib/supabase/middleware.ts](mdc:lib/supabase/middleware.ts))
```typescript
// REQUIRED: Secure authentication middleware with session optimization
import { NextRequest, NextResponse } from 'next/server';
import { createServerClient } from '@supabase/ssr';
import { Database } from './types';
import { logger } from '@lib/utils/logger';

/**
 * High-performance auth middleware with security optimizations
 * Implements session caching and security headers
 */
export async function createAuthMiddleware(request: NextRequest) {
  const startTime = performance.now();
  
  // Create response with security headers
  let response = NextResponse.next({
    request: {
      headers: request.headers,
    },
  });

  // Add security headers (OWASP recommendations)
  response.headers.set('X-Frame-Options', 'DENY');
  response.headers.set('X-Content-Type-Options', 'nosniff');
  response.headers.set('Referrer-Policy', 'strict-origin-when-cross-origin');
  response.headers.set('Permissions-Policy', 'camera=(), microphone=(), geolocation=()');
  
  try {
    // Create Supabase client with optimized SSR configuration
    const supabase = createServerClient<Database>(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
      {
        cookies: {
          get(name: string) {
            return request.cookies.get(name)?.value;
          },
          set(name: string, value: string, options: any) {
            // Secure cookie configuration
            const secureOptions = {
              ...options,
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax' as const,
              maxAge: 60 * 60 * 24 * 7, // 7 days
            };
            
            request.cookies.set({ name, value, ...secureOptions });
            response.cookies.set({ name, value, ...secureOptions });
          },
          remove(name: string, options: any) {
            const secureOptions = {
              ...options,
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax' as const,
            };
            
            request.cookies.set({ name, value: '', ...secureOptions });
            response.cookies.set({ name, value: '', ...secureOptions });
          },
        },
      }
    );

    // Optimized session retrieval with caching
    const { data: { session }, error } = await supabase.auth.getSession();
    
    if (error) {
      logger.error('Auth middleware error:', error);
      // Don't block navigation on auth errors
    }

    // Performance logging
    const duration = performance.now() - startTime;
    logger.performance(`Auth middleware executed in ${duration.toFixed(2)}ms`);

    // Add session info to response headers for client-side optimization
    if (session) {
      response.headers.set('X-User-ID', session.user.id);
      response.headers.set('X-Session-Expires', session.expires_at?.toString() || '');
    }

    return response;

  } catch (error) {
    logger.error('Auth middleware critical error:', error);
    
    // Fail securely - redirect to auth page
    const url = request.nextUrl.clone();
    url.pathname = '/login';
    return NextResponse.redirect(url);
  }
}

/**
 * Route protection utility
 * Implements role-based access control with caching
 */
export function createRouteGuard(allowedRoles: string[] = []) {
  return async function routeGuard(request: NextRequest) {
    const startTime = performance.now();
    
    try {
      const supabase = createServerClient<Database>(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
        {
          cookies: {
            get(name: string) {
              return request.cookies.get(name)?.value;
            },
          },
        }
      );

      const { data: { session } } = await supabase.auth.getSession();
      
      if (!session) {
        const url = request.nextUrl.clone();
        url.pathname = '/login';
        url.searchParams.set('redirectTo', request.nextUrl.pathname);
        return NextResponse.redirect(url);
      }

      // Role-based access control (if roles specified)
      if (allowedRoles.length > 0) {
        const userRole = session.user.user_metadata?.role || 'user';
        
        if (!allowedRoles.includes(userRole)) {
          const url = request.nextUrl.clone();
          url.pathname = '/unauthorized';
          return NextResponse.redirect(url);
        }
      }

      // Log access for security auditing
      logger.security({
        action: 'route_access',
        userId: session.user.id,
        route: request.nextUrl.pathname,
        userAgent: request.headers.get('user-agent'),
        ip: request.ip,
        timestamp: Date.now(),
      });

      const duration = performance.now() - startTime;
      logger.performance(`Route guard executed in ${duration.toFixed(2)}ms`);

      return NextResponse.next();

    } catch (error) {
      logger.error('Route guard error:', error);
      
      const url = request.nextUrl.clone();
      url.pathname = '/error';
      return NextResponse.redirect(url);
    }
  };
}
```

## ⚡ Query Optimization Patterns

### Business Queries ([lib/supabase/queries/business.ts](mdc:lib/supabase/queries/business.ts))
```typescript
// REQUIRED: Optimized business queries with intelligent caching
import { supabase, getPooledClient, Tables } from '../client';
import { CacheManager, CacheStrategies } from '@lib/utils/cacheManager';
import { logger } from '@lib/utils/logger';

type Business = Tables<'businesses'>;
type BusinessWithRelations = Business & {
  reviews: Tables<'reviews'>[];
  categories: Tables<'business_categories'>[];
  photos: Tables<'business_photos'>[];
};

/**
 * High-performance business search with intelligent caching
 * Implements query optimization and result caching
 */
export class BusinessQueries {
  private static readonly CACHE_TTL = 10 * 60 * 1000; // 10 minutes
  private static readonly pooledClient = getPooledClient('business');

  /**
   * Search businesses with advanced filtering and caching
   * Optimized for minimal database round trips
   */
  static async searchBusinesses(params: {
    query?: string;
    location?: string;
    category?: string;
    bounds?: {
      north: number;
      south: number;
      east: number;
      west: number;
    };
    limit?: number;
    offset?: number;
  }): Promise<{
    businesses: BusinessWithRelations[];
    total: number;
    performance: {
      queryTime: number;
      cacheHit: boolean;
    };
  }> {
    const startTime = performance.now();
    const cacheKey = `business_search_${JSON.stringify(params)}`;

    // Check cache first
    const cached = CacheManager.memory.get(cacheKey);
    if (cached) {
      logger.performance(`Business search cache hit: ${cacheKey}`);
      return {
        ...cached,
        performance: {
          queryTime: performance.now() - startTime,
          cacheHit: true,
        },
      };
    }

    try {
      // Build optimized query with proper indexing
      let query = this.pooledClient
        .from('businesses')
        .select(`
          *,
          reviews:reviews(
            id,
            rating,
            text,
            created_at,
            user:users(name, avatar_url)
          ),
          categories:business_categories(
            category:categories(id, name, slug)
          ),
          photos:business_photos(
            id,
            url,
            alt_text,
            is_primary
          )
        `)
        .order('featured', { ascending: false })
        .order('rating', { ascending: false });

      // Apply filters efficiently
      if (params.query) {
        // Use full-text search for performance
        query = query.textSearch('name_fts', params.query, {
          type: 'websearch',
          config: 'english',
        });
      }

      if (params.location) {
        // Geographic search with spatial indexing
        query = query.ilike('address', `%${params.location}%`);
      }

      if (params.category) {
        // Join with categories efficiently
        query = query.eq('business_categories.category.slug', params.category);
      }

      if (params.bounds) {
        // Efficient bounding box query
        query = query
          .gte('latitude', params.bounds.south)
          .lte('latitude', params.bounds.north)
          .gte('longitude', params.bounds.west)
          .lte('longitude', params.bounds.east);
      }

      // Pagination
      const limit = params.limit || 20;
      const offset = params.offset || 0;
      query = query.range(offset, offset + limit - 1);

      // Execute query with performance monitoring
      const { data: businesses, error, count } = await query;

      if (error) {
        logger.error('Business search query error:', error);
        throw error;
      }

      const result = {
        businesses: businesses as BusinessWithRelations[],
        total: count || 0,
      };

      // Cache successful results
      CacheManager.memory.set(cacheKey, result, this.CACHE_TTL);

      const queryTime = performance.now() - startTime;
      logger.performance(`Business search completed in ${queryTime.toFixed(2)}ms`);

      return {
        ...result,
        performance: {
          queryTime,
          cacheHit: false,
        },
      };

    } catch (error) {
      logger.error('Business search error:', error);
      throw error;
    }
  }

  /**
   * Get business by ID with optimized relations loading
   * Implements strategic eager loading to minimize queries
   */
  static async getBusinessById(
    id: string,
    options: {
      includeReviews?: boolean;
      includePhotos?: boolean;
      includeMenus?: boolean;
    } = {}
  ): Promise<BusinessWithRelations | null> {
    const startTime = performance.now();
    const cacheKey = `business_${id}_${JSON.stringify(options)}`;

    // Check cache first
    const cached = CacheManager.memory.get(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      // Build selective query based on options
      let selectFields = `
        *,
        categories:business_categories(
          category:categories(id, name, slug)
        )
      `;

      if (options.includeReviews) {
        selectFields += `,
          reviews:reviews(
            id,
            rating,
            text,
            created_at,
            helpful_count,
            user:users(name, avatar_url)
          )
        `;
      }

      if (options.includePhotos) {
        selectFields += `,
          photos:business_photos(
            id,
            url,
            alt_text,
            is_primary,
            caption
          )
        `;
      }

      if (options.includeMenus) {
        selectFields += `,
          menus:business_menus(
            id,
            name,
            description,
            menu_items:menu_items(
              id,
              name,
              description,
              price,
              category
            )
          )
        `;
      }

      const { data: business, error } = await this.pooledClient
        .from('businesses')
        .select(selectFields)
        .eq('id', id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          return null; // Business not found
        }
        logger.error('Get business by ID error:', error);
        throw error;
      }

      // Cache the result
      CacheManager.memory.set(cacheKey, business, this.CACHE_TTL);

      const queryTime = performance.now() - startTime;
      logger.performance(`Get business by ID completed in ${queryTime.toFixed(2)}ms`);

      return business as BusinessWithRelations;

    } catch (error) {
      logger.error('Get business by ID error:', error);
      throw error;
    }
  }

  /**
   * Get nearby businesses with spatial optimization
   * Uses PostGIS for efficient geographic queries
   */
  static async getNearbyBusinesses(
    latitude: number,
    longitude: number,
    radiusKm: number = 10,
    limit: number = 20
  ): Promise<(Business & { distance: number })[]> {
    const startTime = performance.now();
    const cacheKey = `nearby_${latitude}_${longitude}_${radiusKm}_${limit}`;

    // Check cache first
    const cached = CacheManager.memory.get(cacheKey);
    if (cached) {
      return cached;
    }

    try {
      // Use PostGIS for efficient spatial queries
      const { data: businesses, error } = await this.pooledClient.rpc(
        'get_nearby_businesses',
        {
          lat: latitude,
          lng: longitude,
          radius_km: radiusKm,
          result_limit: limit,
        }
      );

      if (error) {
        logger.error('Nearby businesses query error:', error);
        throw error;
      }

      // Cache the results
      CacheManager.memory.set(cacheKey, businesses, this.CACHE_TTL);

      const queryTime = performance.now() - startTime;
      logger.performance(`Nearby businesses query completed in ${queryTime.toFixed(2)}ms`);

      return businesses;

    } catch (error) {
      logger.error('Nearby businesses error:', error);
      throw error;
    }
  }

  /**
   * Batch operation for efficient bulk queries
   * Minimizes database round trips
   */
  static async getBatchBusinesses(
    ids: string[],
    options: {
      includeReviews?: boolean;
      includePhotos?: boolean;
    } = {}
  ): Promise<BusinessWithRelations[]> {
    const startTime = performance.now();

    // Check for cached results first
    const cacheHits: BusinessWithRelations[] = [];
    const uncachedIds: string[] = [];

    ids.forEach(id => {
      const cacheKey = `business_${id}_${JSON.stringify(options)}`;
      const cached = CacheManager.memory.get(cacheKey);
      if (cached) {
        cacheHits.push(cached);
      } else {
        uncachedIds.push(id);
      }
    });

    if (uncachedIds.length === 0) {
      logger.performance(`Batch businesses fully cached: ${ids.length} items`);
      return cacheHits;
    }

    try {
      // Build efficient batch query
      let selectFields = `
        *,
        categories:business_categories(
          category:categories(id, name, slug)
        )
      `;

      if (options.includeReviews) {
        selectFields += `,
          reviews:reviews(
            id,
            rating,
            text,
            created_at,
            user:users(name, avatar_url)
          )
        `;
      }

      if (options.includePhotos) {
        selectFields += `,
          photos:business_photos(
            id,
            url,
            alt_text,
            is_primary
          )
        `;
      }

      const { data: businesses, error } = await this.pooledClient
        .from('businesses')
        .select(selectFields)
        .in('id', uncachedIds);

      if (error) {
        logger.error('Batch businesses query error:', error);
        throw error;
      }

      // Cache individual results
      businesses?.forEach(business => {
        const cacheKey = `business_${business.id}_${JSON.stringify(options)}`;
        CacheManager.memory.set(cacheKey, business, this.CACHE_TTL);
      });

      const allBusinesses = [...cacheHits, ...(businesses as BusinessWithRelations[])];

      const queryTime = performance.now() - startTime;
      logger.performance(
        `Batch businesses query completed in ${queryTime.toFixed(2)}ms (${uncachedIds.length} new, ${cacheHits.length} cached)`
      );

      return allBusinesses;

    } catch (error) {
      logger.error('Batch businesses error:', error);
      throw error;
    }
  }
}
```

## 🛡️ Row Level Security Implementation

### RLS Policies ([lib/supabase/security/rls.ts](mdc:lib/supabase/security/rls.ts))
```typescript
// REQUIRED: Comprehensive Row Level Security policies
import { supabase } from '../client';
import { logger } from '@lib/utils/logger';

/**
 * RLS Policy Templates and Helpers
 * Implements secure, performance-optimized data access patterns
 */
export class RLSPolicies {
  
  /**
   * Business access policies with performance optimization
   */
  static readonly BUSINESS_POLICIES = {
    // Public read access for published businesses
    public_read: `
      CREATE POLICY "Public businesses are viewable by everyone"
      ON businesses FOR SELECT
      USING (
        status = 'published' 
        AND verified = true
      );
    `,

    // Business owners can manage their own businesses
    owner_full_access: `
      CREATE POLICY "Business owners have full access to their businesses"
      ON businesses FOR ALL
      USING (
        auth.uid() = owner_id
        OR EXISTS (
          SELECT 1 FROM business_managers bm
          WHERE bm.business_id = businesses.id
          AND bm.user_id = auth.uid()
          AND bm.role = 'admin'
        )
      );
    `,

    // Admin access for platform administrators
    admin_access: `
      CREATE POLICY "Admins have full access to all businesses"
      ON businesses FOR ALL
      USING (
        EXISTS (
          SELECT 1 FROM user_roles ur
          WHERE ur.user_id = auth.uid()
          AND ur.role = 'admin'
        )
      );
    `,
  };

  /**
   * Review access policies with moderation
   */
  static readonly REVIEW_POLICIES = {
    // Public read for approved reviews
    public_read: `
      CREATE POLICY "Approved reviews are publicly viewable"
      ON reviews FOR SELECT
      USING (
        status = 'approved'
        AND NOT is_flagged
      );
    `,

    // Users can manage their own reviews
    user_own_reviews: `
      CREATE POLICY "Users can manage their own reviews"
      ON reviews FOR ALL
      USING (auth.uid() = user_id);
    `,

    // Business owners can respond to reviews
    business_response: `
      CREATE POLICY "Business owners can respond to reviews"
      ON review_responses FOR ALL
      USING (
        EXISTS (
          SELECT 1 FROM businesses b
          JOIN reviews r ON r.business_id = b.id
          WHERE r.id = review_responses.review_id
          AND (
            b.owner_id = auth.uid()
            OR EXISTS (
              SELECT 1 FROM business_managers bm
              WHERE bm.business_id = b.id
              AND bm.user_id = auth.uid()
              AND bm.role IN ('admin', 'manager')
            )
          )
        )
      );
    `,
  };

  /**
   * Apply all RLS policies with error handling
   */
  static async applyAllPolicies(): Promise<void> {
    const startTime = performance.now();
    
    try {
      logger.info('Applying RLS policies...');

      // Enable RLS on all tables
      const tables = [
        'businesses',
        'reviews',
        'review_responses',
        'business_photos',
        'business_categories',
        'user_profiles',
        'business_managers',
      ];

      for (const table of tables) {
        await supabase.rpc('enable_rls', { table_name: table });
        logger.debug(`RLS enabled for table: ${table}`);
      }

      // Apply business policies
      for (const [name, policy] of Object.entries(this.BUSINESS_POLICIES)) {
        await supabase.rpc('create_policy', { policy_sql: policy });
        logger.debug(`Applied business policy: ${name}`);
      }

      // Apply review policies
      for (const [name, policy] of Object.entries(this.REVIEW_POLICIES)) {
        await supabase.rpc('create_policy', { policy_sql: policy });
        logger.debug(`Applied review policy: ${name}`);
      }

      const duration = performance.now() - startTime;
      logger.performance(`RLS policies applied in ${duration.toFixed(2)}ms`);

    } catch (error) {
      logger.error('Failed to apply RLS policies:', error);
      throw error;
    }
  }

  /**
   * Validate user permissions for specific operations
   */
  static async validateUserPermission(
    userId: string,
    resource: string,
    action: 'read' | 'write' | 'delete',
    resourceId?: string
  ): Promise<boolean> {
    const startTime = performance.now();

    try {
      const { data, error } = await supabase.rpc('validate_user_permission', {
        user_id: userId,
        resource_type: resource,
        action_type: action,
        resource_id: resourceId,
      });

      if (error) {
        logger.error('Permission validation error:', error);
        return false;
      }

      const duration = performance.now() - startTime;
      logger.performance(`Permission validation completed in ${duration.toFixed(2)}ms`);

      return data?.has_permission || false;

    } catch (error) {
      logger.error('Permission validation failed:', error);
      return false;
    }
  }

  /**
   * Security audit logging
   */
  static async logSecurityEvent(
    userId: string,
    action: string,
    resource: string,
    details: Record<string, any>
  ): Promise<void> {
    try {
      await supabase.from('security_audit_log').insert({
        user_id: userId,
        action,
        resource,
        details,
        ip_address: details.ip,
        user_agent: details.userAgent,
        timestamp: new Date().toISOString(),
      });

      logger.security({
        userId,
        action,
        resource,
        details,
        timestamp: Date.now(),
      });

    } catch (error) {
      logger.error('Security audit logging failed:', error);
      // Don't throw - logging failures shouldn't break the application
    }
  }
}
```

## 📊 Performance Monitoring

### Database Performance Tracking
```typescript
// REQUIRED: Monitor all Supabase operations for performance
export class SupabasePerformanceMonitor {
  private static metrics: Map<string, number[]> = new Map();

  static trackQuery(operation: string, duration: number): void {
    if (!this.metrics.has(operation)) {
      this.metrics.set(operation, []);
    }
    
    const operationMetrics = this.metrics.get(operation)!;
    operationMetrics.push(duration);
    
    // Keep only last 100 measurements
    if (operationMetrics.length > 100) {
      operationMetrics.shift();
    }

    // Alert on slow queries
    if (duration > 1000) {
      logger.warn(`Slow Supabase query: ${operation} took ${duration.toFixed(2)}ms`);
    }

    // Alert on performance degradation
    if (operationMetrics.length >= 10) {
      const average = operationMetrics.reduce((a, b) => a + b) / operationMetrics.length;
      if (average > 500) {
        logger.critical(`Performance degradation detected: ${operation} average ${average.toFixed(2)}ms`);
      }
    }
  }

  static getPerformanceReport(): Record<string, {
    count: number;
    average: number;
    min: number;
    max: number;
  }> {
    const report: Record<string, any> = {};
    
    for (const [operation, durations] of this.metrics) {
      report[operation] = {
        count: durations.length,
        average: durations.reduce((a, b) => a + b) / durations.length,
        min: Math.min(...durations),
        max: Math.max(...durations),
      };
    }
    
    return report;
  }
}
```

## 🚨 Critical Implementation Requirements

### Always Implement:
1. **Connection Pooling**: Use getPooledClient() for specific operations
2. **Query Caching**: Cache all read operations with appropriate TTL
3. **Performance Monitoring**: Track all query execution times
4. **Security Logging**: Log all sensitive operations
5. **Error Boundaries**: Wrap all Supabase calls in try-catch blocks
6. **Type Safety**: Use generated TypeScript types for all operations

### Never Do:
- Make Supabase calls without caching strategy
- Skip RLS policy validation
- Ignore query performance monitoring
- Store sensitive data without encryption
- Use SELECT * in production queries
- Skip connection cleanup

### Performance Targets:
- **Query Response**: <300ms average
- **Cache Hit Rate**: >80% for read operations
- **Connection Utilization**: <70% of pool capacity
- **Error Rate**: <0.1% of all operations

**Remember: Security and performance are not optional - they are requirements.**
